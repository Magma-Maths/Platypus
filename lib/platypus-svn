#!/usr/bin/env bash
#
# platypus-svn.sh - Sync Git main to SVN without rewriting history
#
# Copyright 2025 - Edgar Costa
#
# Part of Platypus - keeps Git monorepo in sync with SVN and subrepos.
#
# This module synchronizes commits from a Git repository to SVN using git-svn.
# It walks origin/main using --first-parent to avoid traversing into merged
# side histories (subtree histories live "behind" merge commits).
#
# For each commit on the first-parent chain, it exports the net diff from its
# first parent: diff(commit^1 -> commit). This works for both normal commits
# and merge commits. Commits with empty exported diffs are skipped.
#
# Progress is tracked via a remote marker branch (default: origin/svn-marker)
# that records the last origin/main commit successfully exported to SVN.
#
# Usage:
#   platypus svn [options]   # Run via top-level platypus driver
# 

# ShellCheck: disable SC2034,SC2154 (variables used via sourced platypus-common.bash)
# Many variables here are used indirectly via dynamic references or exported
# shellcheck disable=2034,2154

# Exit on errors, undefined vars, or broken pipelines:
set -euo pipefail

#------------------------------------------------------------------------------
# Source shared utilities:
#------------------------------------------------------------------------------

# shellcheck source=platypus-common.bash
source "$(dirname "${BASH_SOURCE[0]}")/platypus-common.bash"

#------------------------------------------------------------------------------
# Configuration defaults:
#------------------------------------------------------------------------------

# Remote branch used as pointer to "last exported origin/main commit"
# This is NOT main. Moving it does not rewrite main.
MARKER="${MARKER:-svn-marker}"

# git-svn's tracking ref for SVN trunk
# Common values: refs/remotes/trunk, refs/remotes/git-svn
SVN_REMOTE_REF="${SVN_REMOTE_REF:-refs/remotes/git-svn}"

# Local branch pointing at SVN trunk tip
SVN_BRANCH="${SVN_BRANCH:-svn}"

# Local throwaway branch used for dcommit
EXPORT_BRANCH="${EXPORT_BRANCH:-svn-export}"

#------------------------------------------------------------------------------
# Guard: ensure shared globals are present (enforce single entrypoint)
#------------------------------------------------------------------------------

svn:ensure-globals() {
  ensure:shared-globals
}

#------------------------------------------------------------------------------
# SVN-specific state variables:
# (quiet_wanted, verbose_wanted, debug_wanted, dry_run are in platypus-common.bash)
#------------------------------------------------------------------------------

push_conflicts=false    # Continue through conflicts, push with markers
continue_mode=false     # Resume from saved state
abort_mode=false        # Abort and clean up
cleanup_invoked=false   # Guard to avoid double cleanup

TIP=                    # HEAD commit of origin/main
BASE=                   # Last exported commit (marker position)
COMMITS=                # List of commits to export
PLAN_COMMITS=           # Planned commits to export (first-parent, ordered)
PLAN_COUNT=0            # Count of planned commits

original_branch=        # Branch we started on (for cleanup)
had_conflicts=false     # Track if any conflicts occurred
current_commit=         # Current commit being processed (for state save)

#------------------------------------------------------------------------------
# Cleanup and signal handling:
#------------------------------------------------------------------------------

# Cleanup function called on exit or interrupt:
cleanup() {
  local exit_code=${1:-$?}
  local current_branch return_branch

  # Prefer the branch captured by pipeline:prepare (or any saved state) for cleanup.
  return_branch=$original_branch
  if [[ -z $return_branch && -f "$STATE_DIR/original-branch" ]]; then
    return_branch=$(cat "$STATE_DIR/original-branch" 2>/dev/null || true)
  fi

  # Prevent double cleanup (e.g., ERR + EXIT)
  if $cleanup_invoked; then
    exit "$exit_code"
  fi
  cleanup_invoked=true

  # Don't run cleanup if we're in continue/abort mode (they handle their own cleanup)
  if $continue_mode || $abort_mode; then
    exit "$exit_code"
  fi

  # Get current branch (might be on export branch)
  current_branch=$(git:get-current-branch)

  # If we're on the export branch, switch away first
  if [[ $current_branch == "$EXPORT_BRANCH" ]]; then
    if [[ $return_branch ]]; then
      git switch "$return_branch" 2>/dev/null || git switch "$SVN_BRANCH" 2>/dev/null || true
    else
      git switch "$SVN_BRANCH" 2>/dev/null || true
    fi
  elif [[ $return_branch ]]; then
    # Restore original branch if we changed it
    git switch "$return_branch" 2>/dev/null || true
  fi

  # On success: delete the temporary export branch and state
  # On error: leave export branch for inspection and inform the user
  if [[ $exit_code -eq 0 ]]; then
    git branch -D "$EXPORT_BRANCH" 2>/dev/null || true
    state:clear
  else
    if git branch --list "$EXPORT_BRANCH" | grep -q .; then
      err ""
      err "Export branch '$EXPORT_BRANCH' has been left for inspection."
      err "To clean up manually:  git branch -D $EXPORT_BRANCH"
    fi
    if state:exists; then
      err ""
      err "Operation state saved. To resume after fixing: platypus svn export --continue"
      err "To abort and clean up: platypus svn export --abort"
    fi
  fi

  exit "$exit_code"
}

# Set up trap for cleanup on exit and signals:
trap 'cleanup $?' EXIT ERR INT TERM

#------------------------------------------------------------------------------
# Utility functions (say, o, err, error, RUN are in platypus-common.bash):
#------------------------------------------------------------------------------

# Wrapper to run git commands with step logging:
run_git() {
  local desc=$1
  shift
  o "$desc"
  RUN git "$@"
}

# Print usage and exit:
svn:usage() {
  cat <<'...'
Usage: platypus svn <command> [options]

Sync Git main branch to SVN without rewriting Git history.

Commands:
  update            Update local SVN mirror from SVN server (read-only)
  export            Export origin/main to SVN (fetches origin; no origin push after the fact)
  sync              Full workflow: fetch origin, update SVN mirror, export to SVN, push origin
  --continue        Resume after resolving a conflict
  --abort           Abort in-progress operation and clean up

Options:
  -h, --help         Show this help message
  -v, --verbose      Show verbose step-by-step output
  -q, --quiet        Suppress normal output
  -n, --dry-run      Don't push to SVN or update marker
  -d, --debug        Show git commands as they are executed
  -x                 Turn on Bash debugging (set -x)
  --push-conflicts   Continue through conflicts, push with conflict markers
  --version          Show version information

Environment Variables:
  REMOTE          Git remote name (default: origin)
  MAIN            Main branch to sync from (default: main)
  MARKER          Marker branch for tracking progress (default: svn-marker)
  SVN_REMOTE_REF  git-svn tracking ref (default: refs/remotes/git-svn)
  SVN_BRANCH      Local SVN mirror branch (default: svn)
  EXPORT_BRANCH   Temporary svn-export branch (default: svn-export)
  CONFLICT_LOG    Conflict log file (default: .git/platypus/svngit/conflicts.log)

Exit Codes:
  0   Success - no conflicts
  1   Error - operation failed
  2   Success with conflicts - needs attention

Conflict Tracking (for automation):
  - Commits with conflicts are prefixed with [CONFLICT] in commit messages
  - Git notes are added to commits that had conflicts
  - Conflicts are logged to CONFLICT_LOG file

Examples:
  # Update local SVN mirror from SVN server (read-only)
  platypus svn update

  # Export Git commits to SVN server (does not push to Git origin)
  platypus svn export --verbose

  # Full workflow (fetch + SVN export + push origin)
  platypus svn sync --verbose
  platypus svn sync --debug --dry-run
  platypus svn sync --push-conflicts

  # With custom environment
  REMOTE=upstream MAIN=master platypus svn sync

Automation example:
  platypus svn sync --push-conflicts --quiet
  case $? in
    0) echo "Success" ;;
    1) echo "Error" ;;
    2) echo "Conflicts need review" ;;
  esac
...
  exit 0
}

# Show version:
svn:version() {
  echo "platypus version ${PLATYPUS_VERSION:-unknown} (svn module)"
  exit 0
}

#------------------------------------------------------------------------------
# State management functions (for --continue/--abort):
#------------------------------------------------------------------------------

# Variables to persist. Format: "VARIABLE_NAME:filename"
STATE_VARS=(
  "original_branch:original-branch"
  "BASE:base"
  "TIP:tip"
  "COMMITS:commits-remaining"
  "current_commit:current-commit"
  "had_conflicts:had-conflicts"
)

state:save() {
  mkdir -p "$STATE_DIR"
  local var file
  for item in "${STATE_VARS[@]}"; do
    IFS=':' read -r var file <<< "$item"
    echo "${!var}" > "$STATE_DIR/$file"
  done
}

state:load() {
  local var file
  for item in "${STATE_VARS[@]}"; do
    IFS=':' read -r var file <<< "$item"
    if [[ -f "$STATE_DIR/$file" ]]; then
      local value
      value=$(cat "$STATE_DIR/$file")
      printf -v "$var" '%s' "$value"
    fi
  done
}


# Clear saved state:
state:clear() {
  rm -rf "$STATE_DIR"
}

# Check if state exists:
state:exists() {
  [[ -d "$STATE_DIR" ]]
}

state:update-commits() {
  local processed=$1
  # Filter out the processed commit and save immediately
  COMMITS=$(echo "$COMMITS" | grep -v "^$processed$" || true)
  echo "$COMMITS" > "$STATE_DIR/commits-remaining"
}

# Reset in-memory run state (plan + conflict flags)
state:reset-run() {
  had_conflicts=false
  current_commit=
  PLAN_COMMITS=
  PLAN_COUNT=0
  COMMITS=
}

# Populate COMMITS from the current plan for execution/resume flows
state:materialize-plan() {
  COMMITS="$PLAN_COMMITS"
}

#------------------------------------------------------------------------------
# Conflict logging (for automation):
#------------------------------------------------------------------------------

# Log a conflict to the conflict log file:
log-conflict() {
  local commit=$1
  local type=$2  # "patch", "merge", or "partial"
  local timestamp
  timestamp=$(date -Iseconds 2>/dev/null || date +%Y-%m-%dT%H:%M:%S)
  mkdir -p "$(dirname "$CONFLICT_LOG")"
  echo "$timestamp $type $(git:short-hash "$commit") $commit" >> "$CONFLICT_LOG"
  o "Logged conflict: $type $commit"
}

# Add git note to a commit marking it as having conflicts:
add-conflict-note() {
  local source_commit=$1
  local target_commit=${2:-HEAD}
  git notes add -f -m "svngit: conflict during export from $(git:short-hash "$source_commit")" "$target_commit" 2>/dev/null || true
}

# Mark a conflict in state and attach note/log for tracking
conflict:mark() {
  local source_commit=$1
  local type=$2
  local target_commit=${3:-HEAD}

  had_conflicts=true
  log-conflict "$source_commit" "$type"
  add-conflict-note "$source_commit" "$target_commit"
}

# Print completion warning/exit code if conflicts occurred
conflict:report-outcome() {
  if $had_conflicts; then
    say ""
    say "WARNING: Completed with conflicts."
    say "Files may contain conflict markers (<<<<<<<, =======, >>>>>>>)."
    say "Commits with conflicts are prefixed with [CONFLICT] in commit messages."
    say "Conflict log: $CONFLICT_LOG"
    say "Someone should resolve these in both Git and SVN repositories."
    exit "$EXIT_CONFLICTS"
  fi
}

#------------------------------------------------------------------------------
# Environment checks:
#------------------------------------------------------------------------------

# Check that system is ready for this script:
assert-environment-ok() {
  # Check git is available
  command:exists git ||
    error "Can't find 'git' command in PATH."

  # Check git-svn is available
  git svn --version &> /dev/null ||
    error "Can't find 'git svn' command. Is git-svn installed?"

  # Check git version (optional but recommended)
  local git_version
  git_version=$(git --version | cut -d ' ' -f3)
  o "Git version: $git_version"

  # Use common git validation functions
  git:assert-in-repo
  git:assert-at-root

  # SVN-specific checks only
  local current_branch
  current_branch=$(git:get-current-branch)
  
  [[ $current_branch != "$EXPORT_BRANCH" ]] ||
    error "Can't run while on '$EXPORT_BRANCH'. Switch to another branch first."
  
  [[ $current_branch != "$SVN_BRANCH" ]] ||
    error "Can't run while on '$SVN_BRANCH'. Switch to another branch first."

  # Must be on a branch (not detached HEAD)
  [[ -n $current_branch ]] ||
    error "Must be on a branch to run this command. HEAD is detached."
}

#------------------------------------------------------------------------------
# Command functions (--continue, --abort):
#------------------------------------------------------------------------------

# Abort in-progress operation:
svn:command:abort() {
  state:exists || error "No operation in progress to abort."
  
  state:load
  say "Aborting svngit operation..."
  
  # Abort any in-progress rebase first (from dcommit race condition)
  if git:rebase-in-progress; then
    say "Aborting in-progress rebase..."
    git rebase --abort 2>/dev/null || true
  fi
  
  # Switch away from export branch if needed
  local current_branch
  current_branch=$(git:get-current-branch)
  if [[ $current_branch == "$EXPORT_BRANCH" ]]; then
    git switch "$original_branch" 2>/dev/null || git switch "$SVN_BRANCH" 2>/dev/null || true
  fi
  
  # Clean up export branch
  git branch -D "$EXPORT_BRANCH" 2>/dev/null || true
  
  # Clear state
  state:clear
  
  say "Aborted. Returned to ${original_branch:-previous state}."
}

# Continue after conflict resolution:
svn:command:continue() {
  state:exists || error "No operation in progress to continue."
  state:reset-run
  state:load
  
  say "Resuming svngit operation..."
  $dry_run && say "[DRY RUN MODE]"
  
  # 1. Handle Dcommit Race Condition (Rebase State)
  # If we crashed during dcommit, we are in a rebase. Finish it.
  if git:rebase-in-progress; then
    say "Completing rebase from dcommit race condition..."
    
    # Validation: User must have staged conflict resolutions
    if ! $dry_run && git diff --quiet --cached 2>/dev/null; then
      error "Rebase in progress but no staged changes. Please resolve conflicts, stage them, and try again."
    fi
    
    git:complete-rebase-with-conflicts
    $dry_run || say "Rebase completed."
  fi
  
  # 2. Validation
  git:assert-clean-worktree
  
  # 3. Resume Exporting Commits
  # execute:export-plan handles 'COMMITS' list from state
  if [[ -n $COMMITS ]]; then
    execute:export-plan
  fi
  
  # 4. Finalize (Same steps as pipeline:export)
  sync:dcommit
  sync:advance-marker
  sync:merge-back
  
  # 5. Cleanup
  state:clear
  
  # Explicitly switch back because the 'trap' skips cleanup in --continue mode
  if [[ $original_branch && $original_branch != "$MAIN" ]]; then
    o "Returning to original branch: $original_branch"
    RUN git switch "$original_branch"
  fi
  
  # Prevent double-cleanup if logic changes later
  original_branch=
  
  say "=== Done: resumed and completed export to SVN ==="
  conflict:report-outcome
}

# Get the latest changes from SVN (via git svn rebase) and orign/main (via git fetch):
sync:fetch() {
  # Verify remote exists
  git remote get-url "$REMOTE" &>/dev/null ||
    error "Remote '$REMOTE' does not exist. Check REMOTE variable."

  run_git "Fetch latest state from $REMOTE" fetch --prune "$REMOTE" ||
    error "Failed to fetch from '$REMOTE'. Check network connection."

  # Verify main branch exists on remote
  git:remote-ref-exists "refs/remotes/$REMOTE/$MAIN" ||
    error "Branch '$MAIN' not found on remote '$REMOTE'. Check MAIN variable."

  TIP="$(git rev-parse "$REMOTE/$MAIN")"
  o "Remote tip: $(git:short-hash "$TIP")"
}

# Update local SVN mirror branch to match SVN trunk:
sync:update-svn-mirror() {
  # Verify SVN remote ref exists
  git:rev-exists "$SVN_REMOTE_REF" ||
    error "SVN ref '$SVN_REMOTE_REF' not found. Is git-svn configured?
  Try: git svn init <svn-url>"

  say "Updating SVN mirror branch '$SVN_BRANCH'..."
  run_git "Switch to $SVN_BRANCH tracking $SVN_REMOTE_REF" switch -C "$SVN_BRANCH" "$SVN_REMOTE_REF"

  o "Rebase from SVN"
  if $dry_run; then
    say "[dry-run] Would run: git svn rebase"
    return 0
  fi
  run_git "Rebase from SVN" svn rebase ||
    error "git svn rebase failed. Check SVN server connectivity and authentication."
}

# Initialize marker branch if it doesn't exist:
sync:init-marker() {
  if ! git:remote-ref-exists "refs/remotes/$REMOTE/$MARKER"; then
    local base_init
    base_init="$(git merge-base "$REMOTE/$MAIN" "$SVN_BRANCH")"
    say "Marker $REMOTE/$MARKER missing; initializing to $(git:short-hash "$base_init")"

    if ! $dry_run; then
      RUN git push "$REMOTE" "$base_init:refs/heads/$MARKER" ||
        error "Failed to push marker branch. Check write permissions to '$REMOTE'."
      RUN git fetch "$REMOTE" "refs/heads/$MARKER:refs/remotes/$REMOTE/$MARKER"
      BASE="$(git rev-parse "refs/remotes/$REMOTE/$MARKER")"
    else
      o "[dry-run] Would push marker to $base_init"
      # In dry-run mode, use the computed base since marker doesn't exist yet
      BASE="$base_init"
    fi
  else
    BASE="$(git rev-parse "refs/remotes/$REMOTE/$MARKER")"
  fi

  # Check marker is ancestor of TIP (detect history rewrite)
  if ! git merge-base --is-ancestor "$BASE" "$TIP" 2>/dev/null; then
    err ""
    err "Marker '$MARKER' ($(git:short-hash "$BASE")) is not an ancestor of $REMOTE/$MAIN."
    err "This usually means history was rewritten (force-push or rebase)."
    err ""
    err "To reset marker to current merge-base:"
    err "  git push $REMOTE \$(git merge-base $REMOTE/$MAIN $SVN_BRANCH):refs/heads/$MARKER --force"
    error "Stale marker detected"
  fi

  # Also require marker to be on the first-parent path of MAIN to avoid replaying
  # commits after a rewritten or merged history.
  if ! git rev-list --first-parent "$TIP" | grep -q "$(git rev-parse "$BASE")"; then
    err ""
    err "Marker '$MARKER' ($(git:short-hash "$BASE")) is not on the first-parent path of $REMOTE/$MAIN."
    err "History may have been rewritten or the marker moved off the mainline."
    err ""
    err "To reset marker to current merge-base:"
    err "  git push $REMOTE \$(git merge-base $REMOTE/$MAIN $SVN_BRANCH):refs/heads/$MARKER --force"
    error "Stale marker detected"
  fi

  o "Marker position: $(git:short-hash "$BASE")"
}

# Export planning helpers (first-parent only):
plan:build-export-plan() {
  o "Build export plan: first-parent $BASE..$TIP"

  PLAN_COMMITS="$(git rev-list --reverse --first-parent "$BASE..$TIP" || true)"

  if [[ -n $PLAN_COMMITS ]]; then
    PLAN_COUNT=$(echo "$PLAN_COMMITS" | wc -l | tr -d ' ')
  else
    PLAN_COUNT=0
    say "No new first-parent commits to export ($BASE..$TIP)."
    return 1
  fi

  return 0
}

plan:describe-export-plan() {
  say "Found $PLAN_COUNT commit(s) to export (first-parent $(git:short-hash "$BASE")..$(git:short-hash "$TIP"))."
}

# Primary entrypoint for building the plan used by pipelines
plan:build() {
  if ! plan:build-export-plan; then
    return 1
  fi

  plan:describe-export-plan
  return 0
}

# Prepare the export branch from SVN tip:
sync:prepare-export-branch() {
  o "Create export branch '$EXPORT_BRANCH' from $SVN_BRANCH"
  run_git "Create export branch '$EXPORT_BRANCH' from $SVN_BRANCH" switch -C "$EXPORT_BRANCH" "$SVN_BRANCH"

# Safeguard: ensure export branch starts clean
  if ! $dry_run; then
    RUN git update-index -q --refresh
    git diff-index --quiet HEAD -- ||
      error "Export branch not clean. Something is off."
  fi
}

# Export a single commit to the export branch:
sync:export-commit() {
  local commit=$1
  local p1=$2
  local commit_had_conflict=false
  local conflict_type=""

  o "Export commit $(git:short-hash "$commit")"
  current_commit=$commit

  # In dry-run mode, skip actual patch application
  if $dry_run; then
    say "  [dry-run] Would export: $(git:short-hash "$commit")"
    return 0
  fi

  # Attempt application using helper
  git:try-apply-patch "$p1" "$commit"
  case $? in
    0)   ;; # Clean success
    1)   say "  Warning: Applied with conflicts (3-way): $(git:short-hash "$commit")"
         conflict_type="patch-3way" ;;
    2)   say "  Warning: Partially applied (rejects): $(git:short-hash "$commit")"
         conflict_type="patch-reject" ;;
    128) state:save
         err ""
         err "Failed to apply commit $(git:short-hash "$commit"). Manual resolution required."
         error "Patch apply failed" ;;
  esac


  # Skip empty exports
  if git diff --cached --quiet; then
    RUN git reset --hard -q
    say "  Skip empty export: $(git:short-hash "$commit")"
    return 1
  fi

  # Keep original message and attribution
  local msg author adate cdate conflict_prefix=""
  msg="$(git log -1 --pretty=%B "$commit")"
  author="$(git show -s --format='%an <%ae>' "$commit")"
  adate="$(git show -s --format=%aI "$commit")"
  cdate="$(git show -s --format=%cI "$commit")"

  if [[ -n "$conflict_type" ]]; then
    conflict_prefix="[CONFLICT] "
    conflict:mark "$commit" "$conflict_type"
  fi

  # Commit the exported patch
  GIT_AUTHOR_DATE="$adate" GIT_COMMITTER_DATE="$cdate" \
    RUN git commit --author="$author" -m "${conflict_prefix}${msg}"

  # Log conflict and add git note if there was a conflict
  if $commit_had_conflict; then
    conflict:mark "$commit" "$conflict_type"
  fi

  say "  Exported: $(git:short-hash "$commit") -> $(git log -1 --pretty=%s "$commit" | head -c 50)"
  
  # Update state to mark this commit as processed
  if state:exists; then
    state:update-commits "$commit"
  fi
  
  return 0
}



# Execute the current export plan (uses COMMITS or PLAN_COMMITS):
execute:export-plan() {
  # Prefer materialized COMMITS; fall back to PLAN_COMMITS for convenience
  if [[ -z $COMMITS && -n $PLAN_COMMITS ]]; then
    COMMITS="$PLAN_COMMITS"
  fi

  if [[ -z $COMMITS ]]; then
    say "No commits to export."
    return 1
  fi

  sync:export-commits
}

# Export all commits in the list:
sync:export-commits() {
  local commit p1 exported=0

  for commit in $COMMITS; do
    # Parse commit parents to get first parent
    read -ra line <<<"$(git rev-list --parents -n 1 "$commit")"
    p1="${line[1]:-}"

    if sync:export-commit "$commit" "$p1"; then
      ((exported++)) || true
    fi
  done

  if [[ $exported -eq 0 ]]; then
    say "All commits were empty; nothing to dcommit."
    return 1
  fi

  say "Exported $exported commit(s)."
  return 0
}

# Check if we're in the middle of a rebase:
git:rebase-in-progress() {
  local git_dir
  git_dir=$(git rev-parse --git-dir 2>/dev/null) || return 1
  [[ -d "$git_dir/rebase-merge" || -d "$git_dir/rebase-apply" ]]
}

# Complete an in-progress rebase by adding conflicts and continuing:
git:complete-rebase-with-conflicts() {
  if $dry_run; then
    say "[dry-run] Would complete rebase with conflict markers"
    return 0
  fi
  
  while git:rebase-in-progress; do
    RUN git add -A
    # rebase --continue needs the index staged; if it fails, try to skip
    if ! GIT_EDITOR=true git rebase --continue 2>/dev/null; then
      git rebase --skip 2>/dev/null || break
    fi
  done
}

# Returns: 0=clean apply, 1=applied with conflicts (3-way), 2=applied with rejects, 128=failed
git:try-apply-patch() {
  local p1=$1 commit=$2

  # 1. Try normal apply
  git diff --binary "$p1" "$commit" | git apply --index 2>/dev/null && return 0

  # Stop here if we aren't forcing conflicts
  $push_conflicts || return 128

  # 2. Try 3-way merge
  if git diff --binary "$p1" "$commit" | git apply --3way --index 2>/dev/null; then
    return 1
  fi

  # 3. Try reject mode
  if git diff --binary "$p1" "$commit" | git apply --reject --index 2>/dev/null; then
    git add -A
    return 2
  fi

  # 4. Last resort: add whatever mess resulted (if reject failed but partially applied)
  git add -A 2>/dev/null || true
  return 2
}

# Push commits to SVN via dcommit:
sync:dcommit() {
  if ! git rev-parse --verify -q HEAD >/dev/null; then
    say "Nothing committed on $EXPORT_BRANCH; nothing to dcommit."
    return 1
  fi

  if $dry_run; then
    say "[dry-run] Would run: git svn dcommit"
    return 0
  fi

  say "Pushing to SVN..."
  o "git svn dcommit"
  if ! git svn dcommit; then
    # Check if dcommit failed due to race condition (leaves us in rebase state)
    if git:rebase-in-progress; then
      if $push_conflicts; then
        say "Warning: SVN race condition, resolving with conflict markers"
        git:complete-rebase-with-conflicts
        conflict:mark HEAD "dcommit-race"
        say "Retrying dcommit..."
        RUN git svn dcommit ||
          error "git svn dcommit still failed after resolving rebase."
      else
        state:save
        err ""
        err "SVN dcommit failed: someone else committed to SVN (race condition)."
        err "You are in a rebase state with conflicts."
        err ""
        err "To resolve manually:"
        err "  1. Fix conflicts: git status"
        err "  2. Stage fixes: git add <files>"
        err "  3. Continue rebase: git rebase --continue"
        err "  4. Resume: platypus svn export --continue"
        err ""
        err "Or with conflict markers: platypus svn export --push-conflicts"
        err "Or abort: platypus svn export --abort"
        error "git svn dcommit failed due to SVN race condition."
      fi
    else
      error "git svn dcommit failed. Check SVN permissions and connectivity."
    fi
  fi

  # Refresh SVN mirror after dcommit
  o "Refresh SVN mirror"
  run_git "Switch to $SVN_BRANCH after dcommit" switch "$SVN_BRANCH"
  run_git "Rebase SVN mirror after dcommit" svn rebase
}

# Advance the marker to the new tip:
sync:advance-marker() {
  if $dry_run; then
    say "[dry-run] Would advance marker to $(git:short-hash "$TIP")"
    return 0
  fi

  o "Advance marker to $TIP"
  RUN git push "$REMOTE" "$TIP:refs/heads/$MARKER" ||
    error "Failed to push marker. Check write permissions to '$REMOTE'."
  say "Marker advanced to $(git:short-hash "$TIP")."
}

# Merge SVN changes back into Git main:
sync:merge-back() {
  if $dry_run; then
    say "[dry-run] Would merge SVN changes back to $MAIN"
    return 0
  fi

  say "Merging SVN changes back to $MAIN..."
  run_git "Switch to $MAIN from $REMOTE/$MAIN" switch -C "$MAIN" "$REMOTE/$MAIN"

  o "Merge $SVN_BRANCH into $MAIN"
  if ! git merge --no-ff "$SVN_BRANCH" -m "Merge SVN into $MAIN" 2>/dev/null; then
    if $push_conflicts; then
      say "Warning: Merge has conflicts, committing with markers"
      RUN git add -A
      RUN git commit -m "[CONFLICT] Merge SVN into $MAIN" || true
      conflict:mark "$TIP" "merge"
    else
      err ""
      err "Merge conflict when merging SVN changes back to $MAIN."
      err "This is the final step. To complete manually:"
      err "  1. Resolve conflicts: git status"
      err "  2. Stage resolved: git add <files>"
      err "  3. Commit: git commit"
      err "  4. Push: git push $REMOTE $MAIN"
      error "Merge conflict - manual resolution required"
    fi
  fi
}

#------------------------------------------------------------------------------
# Pipelines (orchestrate pull/push sequences):
#------------------------------------------------------------------------------

pipeline:prepare() {
  # Check environment
  assert-environment-ok

  # Remember original branch for cleanup if not already set (e.g., resume flows)
  if [[ -z $original_branch ]]; then
    original_branch=$(git:get-current-branch)
  fi
  o "Original branch: $original_branch"

  # Require clean working tree
  o "Assert working tree is clean"
  git:assert-clean-worktree

  # Shared setup for update/export
  sync:fetch
  sync:update-svn-mirror
  sync:init-marker
}

pipeline:update() {
  pipeline:prepare

  if plan:build-export-plan; then
    say ""
    say "SVN mirror updated. $PLAN_COUNT commit(s) pending export."
    say "Run 'platypus svn export' to send them to SVN."
  else
    say ""
    say "SVN mirror updated. No pending commits."
  fi

  say "=== Done: SVN update complete ==="
  return 0
}

pipeline:export() {
  pipeline:prepare

  # Build export plan (first-parent)
  if ! plan:build; then
    return 0
  fi
  state:materialize-plan

  # Prepare and execute export
  sync:prepare-export-branch
  if ! sync:export-commits; then
    say "No commits exported (all pending commits were empty exports)."
    say "Advancing marker to $(git:short-hash "$TIP") to avoid reprocessing."
    sync:advance-marker
    return 0
  fi

  # Push to SVN and advance marker
  sync:dcommit
  sync:advance-marker
  sync:merge-back

  say "=== Done: exported $(git:short-hash "$BASE")..$(git:short-hash "$TIP") to SVN ==="

  conflict:report-outcome
  return 0
}

pipeline:sync() {
  # Full workflow wrapper (fetch + export + push origin)
  pipeline:export

  # Push main to origin after successful SVN export
  if $dry_run; then
    say "[dry-run] Would push $MAIN to $REMOTE"
    return 0
  fi

  run_git "Push $MAIN to $REMOTE" push "$REMOTE" "$MAIN" ||
    error "Failed to push $MAIN. Someone may have pushed first.
  Try: git pull --rebase && git push"
}

#------------------------------------------------------------------------------
# Command functions (update/export entrypoints):
#------------------------------------------------------------------------------

svn:command:update() {
  say "=== platypus svn update v${PLATYPUS_VERSION:-unknown} ==="
  $dry_run && say "[DRY RUN MODE]"
  $debug_wanted && say "[DEBUG MODE]"
  
  state:reset-run
  pipeline:update
}

svn:command:export() {
  say "=== platypus svn export v${PLATYPUS_VERSION:-unknown} ==="
  $dry_run && say "[DRY RUN MODE]"
  $debug_wanted && say "[DEBUG MODE]"
  $push_conflicts && say "[PUSH CONFLICTS MODE]"
  
  state:reset-run

  # Check if there's already an operation in progress
  if state:exists; then
    error "An operation is already in progress.
  Use --continue to resume or --abort to cancel."
  fi
  
  pipeline:export
}

svn:command:sync() {
  say "=== platypus svn sync v${PLATYPUS_VERSION:-unknown} ==="
  $dry_run && say "[DRY RUN MODE]"
  $debug_wanted && say "[DEBUG MODE]"
  $push_conflicts && say "[PUSH CONFLICTS MODE]"
  
  state:reset-run

  if state:exists; then
    error "An operation is already in progress.
  Use --continue to resume or --abort to cancel."
  fi

  pipeline:sync
}

#------------------------------------------------------------------------------
# Command dispatch:
#------------------------------------------------------------------------------

svn:dispatch() {
  local cmd=$1
  shift
  
  case "$cmd" in
    update)
      svn:command:update "$@"
      ;;
    export)
      svn:command:export "$@"
      ;;
    sync)
      svn:command:sync "$@"
      ;;
    help|--help|-h)
      svn:usage
      ;;
    *)
      error "Unknown svn command: $cmd. Use 'platypus svn --help' for usage."
      ;;
  esac
}

#------------------------------------------------------------------------------
# SVN-specific option parsing:
#------------------------------------------------------------------------------

svn:parse-specific-options() {
  svn_specific_args=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --push-conflicts)
        push_conflicts=true
        shift
        ;;
      --continue)
        continue_mode=true
        shift
        ;;
      --abort)
        abort_mode=true
        shift
        ;;
      --)
        shift
        svn_specific_args+=("$@")
        break
        ;;
      *)
        svn_specific_args+=("$1")
        shift
        ;;
    esac
  done
}

#------------------------------------------------------------------------------
# Main function:
#------------------------------------------------------------------------------

svn:main() {
  svn:ensure-globals

  svn:parse-specific-options "$@"

  # Parse common options to set verbose_wanted, quiet_wanted, debug_wanted
  common:parse-options "${svn_specific_args[@]:-}"
  eval "set -- \"\${COMMON_PARSE_OPTIONS_REMAINING[@]}\""
  
  # Verbose implies not quiet
  if $verbose_wanted; then
    quiet_wanted=false
  fi
  
  # Debug implies verbose
  if $debug_wanted; then
    verbose_wanted=true
    quiet_wanted=false
  fi
  
  # Can't use both --continue and --abort
  if $continue_mode && $abort_mode; then
    error "Can't use both --continue and --abort."
  fi
  
  # Can't use both --continue and --push-conflicts
  # --continue means "I've manually resolved", --push-conflicts means "auto-resolve"
  if $continue_mode && $push_conflicts; then
    error "Can't use both --continue and --push-conflicts.
  Use --continue after manually resolving conflicts.
  Use --push-conflicts for automatic resolution with conflict markers."
  fi

  # Handle --abort early (no subcommand needed)
  if $abort_mode; then
    svn:command:abort "$@"
    return 0
  fi

  # Handle --continue early (no subcommand needed)
  if $continue_mode; then
    svn:command:continue "$@"
    return 0
  fi
  
  # Use common dispatch for the rest (module-scoped usage/version)
  common:dispatch svn:usage svn:version svn:dispatch "$@"
}

#------------------------------------------------------------------------------
# Entry point:
#------------------------------------------------------------------------------

