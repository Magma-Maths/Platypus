#!/usr/bin/env bash
#
# platypus-svn.sh - Sync Git main to SVN without rewriting history
#
# Copyright 2025 - Edgar Costa
#
# Part of Platypus - keeps Git monorepo in sync with SVN and subrepos.
#
# This module synchronizes commits from a Git repository to SVN using git-svn.
# It walks origin/main using --first-parent to avoid traversing into merged
# side histories (subtree histories live "behind" merge commits).
#
# For each commit on the first-parent chain, it exports the net diff from its
# first parent: diff(commit^1 -> commit). This works for both normal commits
# and merge commits. Commits with empty exported diffs are skipped.
#
# Progress is tracked via a remote marker branch (default: origin/svn-marker)
# that records the last origin/main commit successfully exported to SVN.
#
# Usage:
#   platypus svn [options]   # Run via top-level platypus driver
# 

# ShellCheck: disable SC2034,SC2154 (variables used via sourced platypus-common.bash)
# Many variables here are used indirectly via dynamic references or exported
# shellcheck disable=2034,2154

# Exit on any errors:
set -e

#------------------------------------------------------------------------------
# Source shared utilities:
#------------------------------------------------------------------------------

# shellcheck source=platypus-common.bash
source "$(dirname "${BASH_SOURCE[0]}")/platypus-common.bash"

#------------------------------------------------------------------------------
# Configuration defaults:
#------------------------------------------------------------------------------

# Remote branch used as pointer to "last exported origin/main commit"
# This is NOT main. Moving it does not rewrite main.
MARKER="${MARKER:-svn-marker}"

# git-svn's tracking ref for SVN trunk
# Common values: refs/remotes/trunk, refs/remotes/git-svn
SVN_REMOTE_REF="${SVN_REMOTE_REF:-refs/remotes/git-svn}"

# Local branch pointing at SVN trunk tip
SVN_BRANCH="${SVN_BRANCH:-svn}"

# Local throwaway branch used for dcommit
EXPORT_BRANCH="${EXPORT_BRANCH:-svn-export}"

#------------------------------------------------------------------------------
# Guard: ensure shared globals are present (enforce single entrypoint)
#------------------------------------------------------------------------------

svn:ensure-globals() {
  ensure:shared-globals
}

#------------------------------------------------------------------------------
# SVN-specific state variables:
# (quiet_wanted, verbose_wanted, debug_wanted, dry_run are in platypus-common.bash)
#------------------------------------------------------------------------------

push_conflicts=false    # Continue through conflicts, push with markers
continue_mode=false     # Resume from saved state
abort_mode=false        # Abort and clean up

TIP=                    # HEAD commit of origin/main
BASE=                   # Last exported commit (marker position)
COMMITS=                # List of commits to export
PLAN_COMMITS=           # Planned commits to export (first-parent, ordered)
PLAN_COUNT=0            # Count of planned commits

original_branch=        # Branch we started on (for cleanup)
had_conflicts=false     # Track if any conflicts occurred
current_commit=         # Current commit being processed (for state save)

#------------------------------------------------------------------------------
# Cleanup and signal handling:
#------------------------------------------------------------------------------

# Cleanup function called on exit or interrupt:
cleanup() {
  local exit_code=$?
  local current_branch

  # Don't run cleanup if we're in continue/abort mode (they handle their own cleanup)
  if $continue_mode || $abort_mode; then
    exit $exit_code
  fi

  # Get current branch (might be on export branch)
  current_branch=$(git:get-current-branch)

  # If we're on the export branch, switch away first
  if [[ $current_branch == "$EXPORT_BRANCH" ]]; then
    if [[ $original_branch ]]; then
      git switch "$original_branch" 2>/dev/null || git switch "$SVN_BRANCH" 2>/dev/null || true
    else
      git switch "$SVN_BRANCH" 2>/dev/null || true
    fi
  elif [[ $original_branch ]]; then
    # Restore original branch if we changed it
    git switch "$original_branch" 2>/dev/null || true
  fi

  # On success: delete the temporary export branch and state
  # On error: leave export branch for inspection and inform the user
  if [[ $exit_code -eq 0 ]]; then
    git branch -D "$EXPORT_BRANCH" 2>/dev/null || true
    state:clear
  else
    if git branch --list "$EXPORT_BRANCH" | grep -q .; then
      err ""
      err "Export branch '$EXPORT_BRANCH' has been left for inspection."
      err "To clean up manually:  git branch -D $EXPORT_BRANCH"
    fi
    if state:exists; then
      err ""
      err "Operation state saved. To resume after fixing: platypus svn export --continue"
      err "To abort and clean up: platypus svn export --abort"
    fi
  fi

  exit $exit_code
}

# Set up trap for cleanup on exit and signals:
trap cleanup EXIT INT TERM

#------------------------------------------------------------------------------
# Utility functions (say, o, err, error, RUN are in platypus-common.bash):
#------------------------------------------------------------------------------

# Print usage and exit:
svn:usage() {
  cat <<'...'
Usage: platypus svn <command> [options]

Sync Git main branch to SVN without rewriting Git history.

Commands:
  update            Update local SVN mirror from SVN server (read-only)
  export            Export Git commits to SVN server (does not push to Git origin)
  sync              Full workflow: fetch origin, export to SVN, push origin
  --continue        Resume after resolving a conflict
  --abort           Abort in-progress operation and clean up

Options:
  -h, --help         Show this help message
  -v, --verbose      Show verbose step-by-step output
  -q, --quiet        Suppress normal output
  -n, --dry-run      Don't push to SVN or update marker
  -d, --debug        Show git commands as they are executed
  -x                 Turn on Bash debugging (set -x)
  --push-conflicts   Continue through conflicts, push with conflict markers
  --version          Show version information

Environment Variables:
  REMOTE          Git remote name (default: origin)
  MAIN            Main branch to sync from (default: main)
  MARKER          Marker branch for tracking progress (default: svn-marker)
  SVN_REMOTE_REF  git-svn tracking ref (default: refs/remotes/git-svn)
  SVN_BRANCH      Local SVN mirror branch (default: svn)
  EXPORT_BRANCH   Temporary svn-export branch (default: svn-export)
  CONFLICT_LOG    Conflict log file (default: .git/platypus/svngit/conflicts.log)

Exit Codes:
  0   Success - no conflicts
  1   Error - operation failed
  2   Success with conflicts - needs attention

Conflict Tracking (for automation):
  - Commits with conflicts are prefixed with [CONFLICT] in commit messages
  - Git notes are added to commits that had conflicts
  - Conflicts are logged to CONFLICT_LOG file

Examples:
  # Update local SVN mirror from SVN server (read-only)
  platypus svn update

  # Export Git commits to SVN server (does not push to Git origin)
  platypus svn export --verbose

  # Full workflow (fetch + SVN export + push origin)
  platypus svn sync --verbose
  platypus svn sync --debug --dry-run
  platypus svn sync --push-conflicts

  # With custom environment
  REMOTE=upstream MAIN=master platypus svn sync

Automation example:
  platypus svn sync --push-conflicts --quiet
  case $? in
    0) echo "Success" ;;
    1) echo "Error" ;;
    2) echo "Conflicts need review" ;;
  esac
...
  exit 0
}

# Show version:
svn:version() {
  echo "platypus version ${PLATYPUS_VERSION:-unknown} (svn module)"
  exit 0
}

#------------------------------------------------------------------------------
# State management functions (for --continue/--abort):
#------------------------------------------------------------------------------

# Save current state for resumption:
state:save() {
  mkdir -p "$STATE_DIR"
  echo "$original_branch" > "$STATE_DIR/original-branch"
  echo "$BASE" > "$STATE_DIR/base"
  echo "$TIP" > "$STATE_DIR/tip"
  echo "$COMMITS" > "$STATE_DIR/commits-remaining"
  echo "$current_commit" > "$STATE_DIR/current-commit"
  echo "$had_conflicts" > "$STATE_DIR/had-conflicts"
}

# Load saved state:
state:load() {
  if [[ -f "$STATE_DIR/original-branch" ]]; then
    original_branch=$(cat "$STATE_DIR/original-branch")
  fi
  if [[ -f "$STATE_DIR/base" ]]; then
    BASE=$(cat "$STATE_DIR/base")
  fi
  if [[ -f "$STATE_DIR/tip" ]]; then
    TIP=$(cat "$STATE_DIR/tip")
  fi
  if [[ -f "$STATE_DIR/commits-remaining" ]]; then
    COMMITS=$(cat "$STATE_DIR/commits-remaining")
  fi
  if [[ -f "$STATE_DIR/current-commit" ]]; then
    current_commit=$(cat "$STATE_DIR/current-commit")
  fi
   if [[ -f "$STATE_DIR/had-conflicts" ]]; then
     had_conflicts=$(cat "$STATE_DIR/had-conflicts")
   fi
}

# Clear saved state:
state:clear() {
  rm -rf "$STATE_DIR"
}

# Check if state exists:
state:exists() {
  [[ -d "$STATE_DIR" ]]
}

# Update remaining commits (remove processed ones):
state:update-commits() {
  local processed_commit=$1
  # Remove the processed commit from the list
  COMMITS=$(echo "$COMMITS" | grep -v "^$processed_commit$" || true)
  echo "$COMMITS" > "$STATE_DIR/commits-remaining"
}

# Reset in-memory run state (plan + conflict flags)
state:reset-run() {
  had_conflicts=false
  current_commit=
  PLAN_COMMITS=
  PLAN_COUNT=0
  COMMITS=
}

# Populate COMMITS from the current plan for execution/resume flows
state:materialize-plan() {
  COMMITS="$PLAN_COMMITS"
}

#------------------------------------------------------------------------------
# Conflict logging (for automation):
#------------------------------------------------------------------------------

# Log a conflict to the conflict log file:
log-conflict() {
  local commit=$1
  local type=$2  # "patch", "merge", or "partial"
  local timestamp
  timestamp=$(date -Iseconds 2>/dev/null || date +%Y-%m-%dT%H:%M:%S)
  mkdir -p "$(dirname "$CONFLICT_LOG")"
  echo "$timestamp $type $(git:short-hash "$commit") $commit" >> "$CONFLICT_LOG"
  o "Logged conflict: $type $commit"
}

# Add git note to a commit marking it as having conflicts:
add-conflict-note() {
  local source_commit=$1
  local target_commit=${2:-HEAD}
  git notes add -f -m "svngit: conflict during export from $(git:short-hash "$source_commit")" "$target_commit" 2>/dev/null || true
}

# Mark a conflict in state and attach note/log for tracking
conflict:mark() {
  local source_commit=$1
  local type=$2
  local target_commit=${3:-HEAD}

  had_conflicts=true
  log-conflict "$source_commit" "$type"
  add-conflict-note "$source_commit" "$target_commit"
}

# Print completion warning/exit code if conflicts occurred
conflict:report-outcome() {
  if $had_conflicts; then
    say ""
    say "WARNING: Completed with conflicts."
    say "Files may contain conflict markers (<<<<<<<, =======, >>>>>>>)."
    say "Commits with conflicts are prefixed with [CONFLICT] in commit messages."
    say "Conflict log: $CONFLICT_LOG"
    say "Someone should resolve these in both Git and SVN repositories."
    exit $EXIT_CONFLICTS
  fi
}

#------------------------------------------------------------------------------
# Environment checks:
#------------------------------------------------------------------------------

# Check that system is ready for this script:
assert-environment-ok() {
  # Check git is available
  command:exists git ||
    error "Can't find 'git' command in PATH."

  # Check git-svn is available
  git svn --version &> /dev/null ||
    error "Can't find 'git svn' command. Is git-svn installed?"

  # Check git version (optional but recommended)
  local git_version
  git_version=$(git --version | cut -d ' ' -f3)
  o "Git version: $git_version"

  # Use common git validation functions
  git:assert-in-repo
  git:assert-at-root

  # SVN-specific checks only
  local current_branch
  current_branch=$(git:get-current-branch)
  
  [[ $current_branch != "$EXPORT_BRANCH" ]] ||
    error "Can't run while on '$EXPORT_BRANCH'. Switch to another branch first."
  
  [[ $current_branch != "$SVN_BRANCH" ]] ||
    error "Can't run while on '$SVN_BRANCH'. Switch to another branch first."

  # Must be on a branch (not detached HEAD)
  [[ -n $current_branch ]] ||
    error "Must be on a branch to run this command. HEAD is detached."
}

#------------------------------------------------------------------------------
# Command functions (--continue, --abort):
#------------------------------------------------------------------------------

# Abort in-progress operation:
svn:command:abort() {
  state:exists || error "No operation in progress to abort."
  
  state:load
  say "Aborting svngit operation..."
  
  # Abort any in-progress rebase first (from dcommit race condition)
  if git:rebase-in-progress; then
    say "Aborting in-progress rebase..."
    git rebase --abort 2>/dev/null || true
  fi
  
  # Switch away from export branch if needed
  local current_branch
  current_branch=$(git:get-current-branch)
  if [[ $current_branch == "$EXPORT_BRANCH" ]]; then
    git switch "$original_branch" 2>/dev/null || git switch "$SVN_BRANCH" 2>/dev/null || true
  fi
  
  # Clean up export branch
  git branch -D "$EXPORT_BRANCH" 2>/dev/null || true
  
  # Clear state
  state:clear
  
  say "Aborted. Returned to ${original_branch:-previous state}."
}

# Continue after conflict resolution:
svn:command:continue() {
  state:exists || error "No operation in progress to continue."
  
  state:reset-run
  state:load
  say "Resuming svngit operation..."
  $dry_run && say "[DRY RUN MODE]"
  
  # Check if we're resuming from a dcommit race condition (mid-rebase state)
  if git:rebase-in-progress; then
    say "Completing rebase from dcommit race condition..."
    # User should have resolved conflicts and staged them
    if ! $dry_run && git diff --quiet --cached 2>/dev/null; then
      error "Rebase in progress but no staged changes. Please resolve conflicts, stage them, and try again."
    fi
    
    # Complete the rebase - add conflicts for any remaining commits
    git:complete-rebase-with-conflicts
    $dry_run || say "Rebase completed."
  fi
  
  # User should have resolved and committed
  git:assert-clean-worktree
  
  # Continue with remaining commits
  if [[ -n $COMMITS ]]; then
    execute:export-plan
  fi
  
  sync:dcommit
  sync:advance-marker
  sync:merge-back
  
  # Clear state
  state:clear
  
  # Return to original branch
  if [[ $original_branch && $original_branch != "$MAIN" ]]; then
    o "Returning to original branch: $original_branch"
    RUN git switch "$original_branch"
  fi
  
  # Clear for cleanup trap
  original_branch=
  
  say "=== Done: resumed and completed export to SVN ==="
  
  conflict:report-outcome
}

# Pull latest changes from SVN:
# Fetch latest Git state from remote:
sync:fetch() {
  # Verify remote exists
  git remote get-url "$REMOTE" &>/dev/null ||
    error "Remote '$REMOTE' does not exist. Check REMOTE variable."

  o "Fetch latest state from $REMOTE"
  RUN git fetch --prune "$REMOTE" ||
    error "Failed to fetch from '$REMOTE'. Check network connection."

  # Verify main branch exists on remote
  git:remote-ref-exists "refs/remotes/$REMOTE/$MAIN" ||
    error "Branch '$MAIN' not found on remote '$REMOTE'. Check MAIN variable."

  TIP="$(git rev-parse "$REMOTE/$MAIN")"
  o "Remote tip: $(git:short-hash "$TIP")"
}

# Set TIP from the locally cached remote ref (assumes user fetched already)
sync:set-tip-from-remote() {
  # Verify remote exists
  git remote get-url "$REMOTE" &>/dev/null ||
    error "Remote '$REMOTE' does not exist. Check REMOTE variable."

  # Verify main branch exists on remote (cached)
  git:remote-ref-exists "refs/remotes/$REMOTE/$MAIN" ||
    error "Branch '$MAIN' not found on remote '$REMOTE'. Check MAIN variable."

  TIP="$(git rev-parse "$REMOTE/$MAIN")"
  o "Remote tip (cached): $(git:short-hash "$TIP")"
}

# Update local SVN mirror branch to match SVN trunk:
sync:update-svn-mirror() {
  # Verify SVN remote ref exists
  git:rev-exists "$SVN_REMOTE_REF" ||
    error "SVN ref '$SVN_REMOTE_REF' not found. Is git-svn configured?
  Try: git svn init <svn-url>"

  say "Updating SVN mirror branch '$SVN_BRANCH'..."
  o "Switch to $SVN_BRANCH tracking $SVN_REMOTE_REF"
  RUN git switch -C "$SVN_BRANCH" "$SVN_REMOTE_REF"

  o "Rebase from SVN"
  if $dry_run; then
    say "[dry-run] Would run: git svn rebase"
    return 0
  fi
  RUN git svn rebase ||
    error "git svn rebase failed. Check SVN server connectivity and authentication."
}

# Initialize marker branch if it doesn't exist:
sync:init-marker() {
  if ! git:remote-ref-exists "refs/remotes/$REMOTE/$MARKER"; then
    local base_init
    base_init="$(git merge-base "$REMOTE/$MAIN" "$SVN_BRANCH")"
    say "Marker $REMOTE/$MARKER missing; initializing to $(git:short-hash "$base_init")"

    if ! $dry_run; then
      RUN git push "$REMOTE" "$base_init:refs/heads/$MARKER" ||
        error "Failed to push marker branch. Check write permissions to '$REMOTE'."
      RUN git fetch "$REMOTE" "refs/heads/$MARKER:refs/remotes/$REMOTE/$MARKER"
      BASE="$(git rev-parse "refs/remotes/$REMOTE/$MARKER")"
    else
      o "[dry-run] Would push marker to $base_init"
      # In dry-run mode, use the computed base since marker doesn't exist yet
      BASE="$base_init"
    fi
  else
    BASE="$(git rev-parse "refs/remotes/$REMOTE/$MARKER")"
  fi

  # Check marker is ancestor of TIP (detect history rewrite)
  if ! git merge-base --is-ancestor "$BASE" "$TIP" 2>/dev/null; then
    err ""
    err "Marker '$MARKER' ($(git:short-hash "$BASE")) is not an ancestor of $REMOTE/$MAIN."
    err "This usually means history was rewritten (force-push or rebase)."
    err ""
    err "To reset marker to current merge-base:"
    err "  git push $REMOTE \$(git merge-base $REMOTE/$MAIN $SVN_BRANCH):refs/heads/$MARKER --force"
    error "Stale marker detected"
  fi

  # Also require marker to be on the first-parent path of MAIN to avoid replaying
  # commits after a rewritten or merged history.
  if ! git rev-list --first-parent "$TIP" | grep -q "$(git rev-parse "$BASE")"; then
    err ""
    err "Marker '$MARKER' ($(git:short-hash "$BASE")) is not on the first-parent path of $REMOTE/$MAIN."
    err "History may have been rewritten or the marker moved off the mainline."
    err ""
    err "To reset marker to current merge-base:"
    err "  git push $REMOTE \$(git merge-base $REMOTE/$MAIN $SVN_BRANCH):refs/heads/$MARKER --force"
    error "Stale marker detected"
  fi

  o "Marker position: $(git:short-hash "$BASE")"
}

# Export planning helpers (first-parent only):
plan:build-export-plan() {
  o "Build export plan: first-parent $BASE..$TIP"

  PLAN_COMMITS="$(git rev-list --reverse --first-parent "$BASE..$TIP" || true)"

  if [[ -n $PLAN_COMMITS ]]; then
    PLAN_COUNT=$(echo "$PLAN_COMMITS" | wc -l | tr -d ' ')
  else
    PLAN_COUNT=0
    say "No new first-parent commits to export ($BASE..$TIP)."
    return 1
  fi

  return 0
}

plan:describe-export-plan() {
  say "Found $PLAN_COUNT commit(s) to export (first-parent $(git:short-hash "$BASE")..$(git:short-hash "$TIP"))."
}

# Backwards-compatible wrapper used by existing pipeline
sync:build-commit-list() {
  if ! plan:build-export-plan; then
    COMMITS=""
    return 1
  fi

  plan:describe-export-plan
  COMMITS="$PLAN_COMMITS"
  return 0
}

# Prepare the export branch from SVN tip:
sync:prepare-export-branch() {
  o "Create export branch '$EXPORT_BRANCH' from $SVN_BRANCH"
  RUN git switch -C "$EXPORT_BRANCH" "$SVN_BRANCH"

# Safeguard: ensure export branch starts clean
  if ! $dry_run; then
    RUN git update-index -q --refresh
    git diff-index --quiet HEAD -- ||
      error "Export branch not clean. Something is off."
  fi
}

# Export a single commit to the export branch:
sync:export-commit() {
  local commit=$1
  local p1=$2
  local commit_had_conflict=false
  local conflict_type=""

  o "Export commit $(git:short-hash "$commit")"
  current_commit=$commit

  # In dry-run mode, skip actual patch application
  if $dry_run; then
    say "  [dry-run] Would export: $(git:short-hash "$commit")"
    return 0
  fi

  # Try 1: Normal apply
  if git diff --binary "$p1" "$commit" | git apply --index 2>/dev/null; then
    : # Success - normal apply worked
  
  # Try 2: 3-way merge (with --push-conflicts)
  elif $push_conflicts && git diff --binary "$p1" "$commit" | git apply --3way --index 2>/dev/null; then
    say "  Warning: Applied with conflicts: $(git:short-hash "$commit")"
    commit_had_conflict=true
    conflict_type="patch-3way"
  
  # Try 3: Reject mode (with --push-conflicts)
  elif $push_conflicts; then
    if git diff --binary "$p1" "$commit" | git apply --reject --index 2>/dev/null; then
      git add -A  # Add partial changes
      say "  Warning: Partially applied (see .rej files): $(git:short-hash "$commit")"
      commit_had_conflict=true
      conflict_type="patch-reject"
    else
      # Even reject mode failed, but we're in push-conflicts mode
      git add -A 2>/dev/null || true
      say "  Warning: Failed to apply, continuing anyway: $(git:short-hash "$commit")"
      commit_had_conflict=true
      conflict_type="patch-failed"
    fi
  
  else
    # All strategies failed and not in push-conflicts mode
    state:save
    err ""
    err "Failed to apply commit $(git:short-hash "$commit")"
    err ""
    err "To resolve manually:"
    err "  1. Inspect: git diff $p1 $commit"
    err "  2. Apply with conflicts: git diff --binary $p1 $commit | git apply --3way"
    err "  3. Fix conflicts, then: git add -A && git commit"
    err "  4. Resume: platypus svn export --continue"
    err ""
    err "Or abort: platypus svn export --abort"
    err "Or retry with: platypus svn export --push-conflicts"
    error "Patch apply failed"
  fi

  # Skip commits with empty exported diff
  if git diff --cached --quiet; then
    RUN git reset --hard -q
    say "  Skip empty export: $(git:short-hash "$commit")"
    return 1
  fi

  # Keep original message and attribution
  local msg author adate cdate
  msg="$(git log -1 --pretty=%B "$commit")"
  author="$(git show -s --format='%an <%ae>' "$commit")"
  adate="$(git show -s --format=%aI "$commit")"
  cdate="$(git show -s --format=%cI "$commit")"

  # Mark commit message if it had conflicts
  local conflict_prefix=""
  if $commit_had_conflict; then
    conflict_prefix="[CONFLICT] "
  fi

  # Commit the exported patch
  GIT_AUTHOR_DATE="$adate" GIT_COMMITTER_DATE="$cdate" \
    RUN git commit --author="$author" -m "${conflict_prefix}${msg}"

  # Log conflict and add git note if there was a conflict
  if $commit_had_conflict; then
    conflict:mark "$commit" "$conflict_type"
  fi

  say "  Exported: $(git:short-hash "$commit") -> $(git log -1 --pretty=%s "$commit" | head -c 50)"
  
  # Update state to mark this commit as processed
  if state:exists; then
    state:update-commits "$commit"
  fi
  
  return 0
}

# Execute the current export plan (uses COMMITS or PLAN_COMMITS):
execute:export-plan() {
  # Prefer materialized COMMITS; fall back to PLAN_COMMITS for convenience
  if [[ -z $COMMITS && -n $PLAN_COMMITS ]]; then
    COMMITS="$PLAN_COMMITS"
  fi

  if [[ -z $COMMITS ]]; then
    say "No commits to export."
    return 1
  fi

  sync:export-commits
}

# Export all commits in the list:
sync:export-commits() {
  local commit p1 exported=0

  for commit in $COMMITS; do
    # Parse commit parents to get first parent
    read -ra line <<<"$(git rev-list --parents -n 1 "$commit")"
    p1="${line[1]}"

    if sync:export-commit "$commit" "$p1"; then
      ((exported++)) || true
    fi
  done

  if [[ $exported -eq 0 ]]; then
    say "All commits were empty; nothing to dcommit."
    return 1
  fi

  say "Exported $exported commit(s)."
  return 0
}

# Check if we're in the middle of a rebase:
git:rebase-in-progress() {
  local git_dir
  git_dir=$(git rev-parse --git-dir 2>/dev/null) || return 1
  [[ -d "$git_dir/rebase-merge" || -d "$git_dir/rebase-apply" ]]
}

# Complete an in-progress rebase by adding conflicts and continuing:
git:complete-rebase-with-conflicts() {
  if $dry_run; then
    say "[dry-run] Would complete rebase with conflict markers"
    return 0
  fi
  
  while git:rebase-in-progress; do
    RUN git add -A
    # rebase --continue needs the index staged; if it fails, try to skip
    if ! GIT_EDITOR=true git rebase --continue 2>/dev/null; then
      git rebase --skip 2>/dev/null || break
    fi
  done
}

# Push commits to SVN via dcommit:
sync:dcommit() {
  if ! git rev-parse --verify -q HEAD >/dev/null; then
    say "Nothing committed on $EXPORT_BRANCH; nothing to dcommit."
    return 1
  fi

  if $dry_run; then
    say "[dry-run] Would run: git svn dcommit"
    return 0
  fi

  say "Pushing to SVN..."
  o "git svn dcommit"
  if ! git svn dcommit; then
    # Check if dcommit failed due to race condition (leaves us in rebase state)
    if git:rebase-in-progress; then
      if $push_conflicts; then
        say "Warning: SVN race condition, resolving with conflict markers"
        git:complete-rebase-with-conflicts
        conflict:mark HEAD "dcommit-race"
        say "Retrying dcommit..."
        RUN git svn dcommit ||
          error "git svn dcommit still failed after resolving rebase."
      else
        state:save
        err ""
        err "SVN dcommit failed: someone else committed to SVN (race condition)."
        err "You are in a rebase state with conflicts."
        err ""
        err "To resolve manually:"
        err "  1. Fix conflicts: git status"
        err "  2. Stage fixes: git add <files>"
        err "  3. Continue rebase: git rebase --continue"
        err "  4. Resume: platypus svn export --continue"
        err ""
        err "Or with conflict markers: platypus svn export --push-conflicts"
        err "Or abort: platypus svn export --abort"
        error "git svn dcommit failed due to SVN race condition."
      fi
    else
      error "git svn dcommit failed. Check SVN permissions and connectivity."
    fi
  fi

  # Refresh SVN mirror after dcommit
  o "Refresh SVN mirror"
  RUN git switch "$SVN_BRANCH"
  RUN git svn rebase
}

# Advance the marker to the new tip:
sync:advance-marker() {
  if $dry_run; then
    say "[dry-run] Would advance marker to $(git:short-hash "$TIP")"
    return 0
  fi

  o "Advance marker to $TIP"
  RUN git push "$REMOTE" "$TIP:refs/heads/$MARKER" ||
    error "Failed to push marker. Check write permissions to '$REMOTE'."
  say "Marker advanced to $(git:short-hash "$TIP")."
}

# Merge SVN changes back into Git main:
sync:merge-back() {
  if $dry_run; then
    say "[dry-run] Would merge SVN changes back to $MAIN"
    return 0
  fi

  say "Merging SVN changes back to $MAIN..."
  o "Switch to $MAIN from $REMOTE/$MAIN"
  RUN git switch -C "$MAIN" "$REMOTE/$MAIN"

  o "Merge $SVN_BRANCH into $MAIN"
  if ! git merge --no-ff "$SVN_BRANCH" -m "Merge SVN into $MAIN" 2>/dev/null; then
    if $push_conflicts; then
      say "Warning: Merge has conflicts, committing with markers"
      RUN git add -A
      RUN git commit -m "[CONFLICT] Merge SVN into $MAIN" || true
      conflict:mark "$TIP" "merge"
    else
      err ""
      err "Merge conflict when merging SVN changes back to $MAIN."
      err "This is the final step. To complete manually:"
      err "  1. Resolve conflicts: git status"
      err "  2. Stage resolved: git add <files>"
      err "  3. Commit: git commit"
      err "  4. Push: git push $REMOTE $MAIN"
      error "Merge conflict - manual resolution required"
    fi
  fi
}

#------------------------------------------------------------------------------
# Pipelines (orchestrate pull/push sequences):
#------------------------------------------------------------------------------

pipeline:pull() {
  # Check environment
  assert-environment-ok
  
  # Remember original branch for cleanup
  original_branch=$(git:get-current-branch)
  o "Original branch: $original_branch"
  
  # Require clean working tree
  o "Assert working tree is clean"
  git:assert-clean-worktree
  
  # Step 1: Fetch latest Git state (needed for marker check)
  sync:fetch
  
  # Step 2: Update SVN mirror (the actual update)
  sync:update-svn-mirror
  
  # Step 3: Ensure marker exists and show status
  sync:init-marker
  
  # Show what commits are available to export
  local pending_commits pending_count
  pending_commits=$(git rev-list --first-parent "$BASE..$TIP" 2>/dev/null || true)
  if [[ -n "$pending_commits" ]]; then
    pending_count=$(echo "$pending_commits" | wc -l | tr -d ' ')
    say ""
    say "SVN mirror updated. $pending_count commit(s) pending to export."
    say "Run 'platypus svn export' to export them to SVN (or 'platypus svn sync' for full workflow)."
  else
    say ""
    say "SVN mirror updated. No commits pending."
  fi
  
  # Return to original branch
  if [[ $original_branch && $original_branch != "$SVN_BRANCH" ]]; then
    o "Returning to original branch: $original_branch"
    RUN git switch "$original_branch"
  fi
  
  # Clear for cleanup trap
  original_branch=
  
  say "=== Done: SVN update complete ==="
  return 0
}

pipeline:push() {
  # Check environment
  assert-environment-ok
  
  # Remember original branch for cleanup
  original_branch=$(git:get-current-branch)
  o "Original branch: $original_branch"
  
  # Require clean working tree
  o "Assert working tree is clean"
  git:assert-clean-worktree
  
  # Step 1: Fetch latest Git state (sets TIP)
  sync:fetch
  
  # Step 2: Update SVN mirror (ensure we have latest SVN state)
  sync:update-svn-mirror
  
  # Step 3: Ensure marker exists
  sync:init-marker
  
  # Step 4: Build export plan
  if ! plan:build-export-plan; then
    # Return to original branch
    if [[ $original_branch && $original_branch != "$SVN_BRANCH" ]]; then
      RUN git switch "$original_branch"
    fi
    original_branch=
    return 0
  fi
  plan:describe-export-plan
  state:materialize-plan
  
  # Step 5: Prepare export branch
  sync:prepare-export-branch
  
  # Step 6: Execute export plan
  if ! execute:export-plan; then
    say "No commits exported; leaving marker at $(git:short-hash "$BASE")."
    # Return to original branch
    if [[ $original_branch && $original_branch != "$MAIN" ]]; then
      RUN git switch "$original_branch"
    fi
    original_branch=
    return 0
  fi
  
  # Step 7: Push to SVN
  sync:dcommit
  
  # Step 8: Advance marker
  sync:advance-marker
  
  # Step 9: Merge back to main
  sync:merge-back
  
  # Step 10: Return to original branch
  if [[ $original_branch && $original_branch != "$MAIN" ]]; then
    o "Returning to original branch: $original_branch"
    RUN git switch "$original_branch"
  fi
  
  # Clear original_branch so cleanup trap doesn't try to switch again
  original_branch=
  
  say "=== Done: exported $(git:short-hash "$BASE")..$(git:short-hash "$TIP") to SVN ==="
  
  conflict:report-outcome
  return 0
}

pipeline:sync() {
  # Full workflow wrapper (fetch + push + push origin)
  sync:fetch
  pipeline:push

  # Push main to origin after successful SVN export
  if $dry_run; then
    say "[dry-run] Would push $MAIN to $REMOTE"
    return 0
  fi

  o "Push $MAIN to $REMOTE"
  RUN git push "$REMOTE" "$MAIN" ||
    error "Failed to push $MAIN. Someone may have pushed first.
  Try: git pull --rebase && git push"
}

#------------------------------------------------------------------------------
# Command functions (update/export entrypoints):
#------------------------------------------------------------------------------

# Update local SVN mirror from SVN server (read-only):
svn:command:update() {
  say "=== platypus svn update v${PLATYPUS_VERSION:-unknown} ==="
  $dry_run && say "[DRY RUN MODE]"
  $debug_wanted && say "[DEBUG MODE]"
  
  state:reset-run
  pipeline:pull
}

# Export Git commits to SVN:
svn:command:export() {
  say "=== platypus svn export v${PLATYPUS_VERSION:-unknown} ==="
  $dry_run && say "[DRY RUN MODE]"
  $debug_wanted && say "[DEBUG MODE]"
  $push_conflicts && say "[PUSH CONFLICTS MODE]"
  
  state:reset-run

  # Check if there's already an operation in progress
  if state:exists; then
    error "An operation is already in progress.
  Use --continue to resume or --abort to cancel."
  fi
  
  pipeline:push
}

# Full workflow: fetch, SVN export, merge, push to origin
svn:command:sync() {
  say "=== platypus svn sync v${PLATYPUS_VERSION:-unknown} ==="
  $dry_run && say "[DRY RUN MODE]"
  $debug_wanted && say "[DEBUG MODE]"
  $push_conflicts && say "[PUSH CONFLICTS MODE]"
  
  state:reset-run

  if state:exists; then
    error "An operation is already in progress.
  Use --continue to resume or --abort to cancel."
  fi

  pipeline:sync
}

#------------------------------------------------------------------------------
# Command dispatch:
#------------------------------------------------------------------------------

svn:dispatch() {
  local cmd=$1
  shift
  
  case "$cmd" in
    update)
      svn:command:update "$@"
      ;;
    export)
      svn:command:export "$@"
      ;;
    sync)
      svn:command:sync "$@"
      ;;
    help|--help|-h)
      svn:usage
      ;;
    *)
      error "Unknown svn command: $cmd. Use 'platypus svn --help' for usage."
      ;;
  esac
}

#------------------------------------------------------------------------------
# SVN-specific option parsing:
#------------------------------------------------------------------------------

svn:parse-specific-options() {
  svn_specific_args=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --push-conflicts)
        push_conflicts=true
        shift
        ;;
      --continue)
        continue_mode=true
        shift
        ;;
      --abort)
        abort_mode=true
        shift
        ;;
      --)
        shift
        svn_specific_args+=("$@")
        break
        ;;
      *)
        svn_specific_args+=("$1")
        shift
        ;;
    esac
  done
}

#------------------------------------------------------------------------------
# Main function:
#------------------------------------------------------------------------------

svn:main() {
  svn:ensure-globals

  svn:parse-specific-options "$@"

  # Parse common options to set verbose_wanted, quiet_wanted, debug_wanted
  common:parse-options "${svn_specific_args[@]}"
  eval "set -- \"\${COMMON_PARSE_OPTIONS_REMAINING[@]}\""
  
  # Verbose implies not quiet
  if $verbose_wanted; then
    quiet_wanted=false
  fi
  
  # Debug implies verbose
  if $debug_wanted; then
    verbose_wanted=true
    quiet_wanted=false
  fi
  
  # Can't use both --continue and --abort
  if $continue_mode && $abort_mode; then
    error "Can't use both --continue and --abort."
  fi
  
  # Can't use both --continue and --push-conflicts
  # --continue means "I've manually resolved", --push-conflicts means "auto-resolve"
  if $continue_mode && $push_conflicts; then
    error "Can't use both --continue and --push-conflicts.
  Use --continue after manually resolving conflicts.
  Use --push-conflicts for automatic resolution with conflict markers."
  fi

  # Handle --abort early (no subcommand needed)
  if $abort_mode; then
    svn:command:abort
    return 0
  fi

  # Handle --continue early (no subcommand needed)
  if $continue_mode; then
    svn:command:continue
    return 0
  fi
  
  # Use common dispatch for the rest (module-scoped usage/version)
  common:dispatch svn:usage svn:version svn:dispatch "$@"
}

#------------------------------------------------------------------------------
# Entry point:
#------------------------------------------------------------------------------

