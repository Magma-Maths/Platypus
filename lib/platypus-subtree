#!/usr/bin/env bash
#
# platypus-subtree.sh - Manage Git subtrees in the monorepo
#
# Copyright 2025 - Edgar Costa
#
# Part of Platypus - keeps Git monorepo in sync with SVN and subtrees.
#
# DESIGN DECISIONS:
#
# 1. Configuration stored in .gitsubtrees at repository root (like .gitmodules)
#    - Enables direct use of `git subtree` without filtering
#    - With 50k+ commits, in-directory config would require filter-branch on
#      every push (hours of rewriting). Root config = zero filtering overhead.
#
# 2. Uses native `git subtree` commands directly
#    - Mature, handles edge cases (merges, renames, empty commits)
#    - We add value through: config management, incremental split optimization
#    - Lower maintenance - upstream Git fixes benefit us automatically
#
# 3. Tracks splitSha for incremental push optimization
#    - First push: full `git subtree split` (slow on large repos)
#    - Subsequent pushes: `git subtree split --onto=<splitSha>` (fast!)
#
# Usage:
#   platypus subtree <command> [options]
#
# Configuration file format (.gitsubtrees):
#   [subtree "lib/foo"]
#       remote = git@github.com:owner/foo.git
#       branch = main
#       upstream = <last synced upstream commit>
#       preMergeParent = <monorepo commit BEFORE last sync>
#       splitSha = <last split result for incremental push>
#

set -e

#------------------------------------------------------------------------------
# Configuration:
#------------------------------------------------------------------------------

VERSION=0.0.1
CONFIG_FILE=".gitsubtrees"

#------------------------------------------------------------------------------
# Global state:
#------------------------------------------------------------------------------

quiet_wanted=false
verbose_wanted=false
dry_run=false
debug_wanted=false

# Will be set by find-repo-root
REPO_ROOT=""
CONFIG_PATH=""

#------------------------------------------------------------------------------
# Utility functions:
#------------------------------------------------------------------------------

say() {
  $quiet_wanted || echo "$@"
}

o() {
  if $verbose_wanted; then
    echo "  * $*"
  fi
}

debug() {
  if $debug_wanted; then
    echo "DEBUG: $*" >&2
  fi
}

err() {
  echo "$@" >&2
}

error() {
  echo "ERROR: $*" >&2
  exit 1
}

# Run a command, optionally showing it in verbose/debug mode
RUN() {
  if $debug_wanted; then
    echo "+ $*" >&2
  elif $verbose_wanted; then
    echo "  > $*" >&2
  fi
  
  if $dry_run; then
    return 0
  fi
  
  "$@"
}

#------------------------------------------------------------------------------
# Repository and config file location:
#------------------------------------------------------------------------------

# Find the repository root directory
find-repo-root() {
  REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null) ||
    error "Not in a git repository."
  CONFIG_PATH="$REPO_ROOT/$CONFIG_FILE"
}

# Ensure we're in a git repo and have found the config path
ensure-repo-root() {
  if [[ -z "$REPO_ROOT" ]]; then
    find-repo-root
  fi
}

#------------------------------------------------------------------------------
# Configuration functions (.gitsubtrees):
#
# Config file uses git-config INI format, allowing us to use `git config -f`
# for reading and writing. Example:
#
#   [subtree "lib/foo"]
#       remote = git@github.com:owner/foo.git
#       branch = main
#       upstream = abc123...
#       parent = def456...
#       splitSha = 789abc...
#------------------------------------------------------------------------------

# Get a config value for a subtree
# Usage: config:get <prefix> <key>
config:get() {
  local prefix=$1
  local key=$2
  ensure-repo-root
  
  if [[ ! -f "$CONFIG_PATH" ]]; then
    return 1
  fi
  
  git config -f "$CONFIG_PATH" "subtree.${prefix}.${key}" 2>/dev/null
}

# Set a config value for a subtree
# Usage: config:set <prefix> <key> <value>
config:set() {
  local prefix=$1
  local key=$2
  local value=$3
  ensure-repo-root
  
  # Create config file if it doesn't exist
  if [[ ! -f "$CONFIG_PATH" ]]; then
    cat > "$CONFIG_PATH" << 'EOF'
# Platypus subtree configuration
# This file tracks Git subtrees managed by platypus.
# Format is similar to .gitmodules.
#
# Do not edit manually unless you know what you're doing.
# Use: platypus subtree init/add/pull/push commands.

EOF
  fi
  
  git config -f "$CONFIG_PATH" "subtree.${prefix}.${key}" "$value"
}

# Remove a config key for a subtree
# Usage: config:unset <prefix> <key>
config:unset() {
  local prefix=$1
  local key=$2
  ensure-repo-root
  
  if [[ -f "$CONFIG_PATH" ]]; then
    git config -f "$CONFIG_PATH" --unset "subtree.${prefix}.${key}" 2>/dev/null || true
  fi
}

# Remove entire subtree section from config
# Usage: config:remove-section <prefix>
config:remove-section() {
  local prefix=$1
  ensure-repo-root
  
  if [[ -f "$CONFIG_PATH" ]]; then
    git config -f "$CONFIG_PATH" --remove-section "subtree.${prefix}" 2>/dev/null || true
  fi
}

# Check if a subtree is configured
# Usage: config:exists <prefix>
config:exists() {
  local prefix=$1
  ensure-repo-root
  
  if [[ ! -f "$CONFIG_PATH" ]]; then
    return 1
  fi
  
  # git config keeps slashes in section names, so we match literally
  # We need to escape dots in prefix for regex, but keep slashes
  local escaped_prefix="${prefix//./\\.}"
  git config -f "$CONFIG_PATH" --get-regexp "^subtree\\.${escaped_prefix}\\." &>/dev/null
}

# List all configured subtree prefixes
# Usage: config:list
config:list() {
  ensure-repo-root
  
  if [[ ! -f "$CONFIG_PATH" ]]; then
    return 0
  fi
  
  git config -f "$CONFIG_PATH" --get-regexp '^subtree\.' 2>/dev/null |
    sed -n 's/^subtree\.\([^.]*\)\.remote.*/\1/p' |
    sort -u
}

# Get all config for a subtree as key=value lines
# Usage: config:get-all <prefix>
config:get-all() {
  local prefix=$1
  ensure-repo-root
  
  if [[ ! -f "$CONFIG_PATH" ]]; then
    return 0
  fi
  
  # Escape dots in prefix for regex, keep slashes
  local escaped_prefix="${prefix//./\\.}"
  git config -f "$CONFIG_PATH" --get-regexp "^subtree\\.${escaped_prefix}\\." 2>/dev/null |
    sed "s/^subtree\\.${escaped_prefix}\\.//"
}

#------------------------------------------------------------------------------
# Subtree helper functions:
#------------------------------------------------------------------------------

# Assert that a subtree prefix is configured
# Usage: subtree:assert-configured <prefix>
subtree:assert-configured() {
  local prefix=$1
  
  if ! config:exists "$prefix"; then
    error "Subtree '$prefix' is not configured in $CONFIG_FILE.
Use 'platypus subtree init $prefix' or 'platypus subtree add $prefix <repo>' first."
  fi
}

# Assert that a directory exists and is not empty
# Usage: subtree:assert-directory-exists <prefix>
subtree:assert-directory-exists() {
  local prefix=$1
  ensure-repo-root
  
  local dir="$REPO_ROOT/$prefix"
  if [[ ! -d "$dir" ]]; then
    error "Directory '$prefix' does not exist."
  fi
  
  if [[ -z "$(ls -A "$dir" 2>/dev/null)" ]]; then
    error "Directory '$prefix' is empty."
  fi
}

# Assert that a directory does NOT exist (for add command)
# Usage: subtree:assert-directory-not-exists <prefix>
subtree:assert-directory-not-exists() {
  local prefix=$1
  ensure-repo-root
  
  local dir="$REPO_ROOT/$prefix"
  if [[ -d "$dir" ]] && [[ -n "$(ls -A "$dir" 2>/dev/null)" ]]; then
    error "Directory '$prefix' already exists and is not empty.
Use 'platypus subtree init $prefix' to register an existing directory."
  fi
}

# Fetch from a subtree's configured remote
# Usage: subtree:fetch <prefix>
subtree:fetch() {
  local prefix=$1
  
  subtree:assert-configured "$prefix"
  
  local remote branch
  remote=$(config:get "$prefix" remote) || error "No remote configured for '$prefix'"
  branch=$(config:get "$prefix" branch) || branch="main"
  
  o "Fetching $remote ($branch)..."
  RUN git fetch "$remote" "$branch"
}

# Get the tracking ref name for a subtree
# Usage: subtree:tracking-ref <prefix>
subtree:tracking-ref() {
  local prefix=$1
  # Sanitize prefix for use in ref name (replace / with -)
  echo "subtree/${prefix//\//-}"
}

# Assert the working tree is clean
# Usage: subtree:assert-clean-worktree
subtree:assert-clean-worktree() {
  ensure-repo-root
  cd "$REPO_ROOT"
  
  git update-index -q --ignore-submodules --refresh
  
  if ! git diff-files --quiet --ignore-submodules; then
    error "Working tree has unstaged changes. Please commit or stash them first."
  fi
  
  if ! git diff-index --quiet --ignore-submodules HEAD --; then
    error "Working tree has staged but uncommitted changes. Please commit or stash them first."
  fi
}

# Normalize a prefix (remove trailing slash, validate)
# Usage: subtree:normalize-prefix <prefix>
subtree:normalize-prefix() {
  local prefix=$1
  
  # Remove trailing slash
  prefix="${prefix%/}"
  
  # Remove leading slash
  prefix="${prefix#/}"
  
  # Validate: no .., no absolute paths
  if [[ "$prefix" == *".."* ]]; then
    error "Invalid prefix: '$prefix' (contains '..')"
  fi
  
  if [[ "$prefix" == /* ]]; then
    error "Invalid prefix: '$prefix' (absolute path not allowed)"
  fi
  
  if [[ -z "$prefix" ]]; then
    error "Prefix cannot be empty"
  fi
  
  echo "$prefix"
}

#------------------------------------------------------------------------------
# Help:
#------------------------------------------------------------------------------

usage() {
  cat <<'EOF'
Usage: platypus subtree <command> [options]

Manage Git subtrees in the monorepo. Configuration is stored in .gitsubtrees
at the repository root (similar to .gitmodules).

Commands:
  create <prefix> <upstream> [-b <branch>]
                    Export existing directory to a new upstream repo
  init <prefix> [-r <remote>] [-b <branch>]
                    Link existing directory to an existing upstream
  add <prefix> <repo> [<ref>]
                    Add a new subtree from a remote repository
  pull <prefix>     Pull upstream changes into subtree
  push <prefix>     Push subtree changes to upstream
  sync <prefix>     Bidirectional sync (pull then push)
  status [<prefix>] Show sync status of subtree(s)
  list              List all configured subtrees

Options:
  -h, --help        Show this help message
  -v, --verbose     Show verbose output
  -q, --quiet       Suppress normal output
  -n, --dry-run     Show what would be done without doing it
  -d, --debug       Show debug output
  --version         Show version information

For create/init commands:
  -b, --branch      Remote branch (default: main)
  -r, --remote      Remote repository URL (init only)

Examples:
  # Export existing lib/foo to a new upstream repo
  platypus subtree create lib/foo git@github.com:owner/foo.git

  # Link existing lib/foo to an existing upstream
  platypus subtree init lib/foo -r git@github.com:owner/foo.git

  # Add a new subtree from a remote
  platypus subtree add lib/bar git@github.com:owner/bar.git main

  # Pull upstream changes
  platypus subtree pull lib/foo

  # Push local changes to upstream
  platypus subtree push lib/foo

  # Bidirectional sync (pull then push)
  platypus subtree sync lib/foo

  # Show status of all subtrees
  platypus subtree status

Configuration file (.gitsubtrees):
  [subtree "lib/foo"]
      remote = git@github.com:owner/foo.git
      branch = main
      upstream = <last synced upstream commit>
      preMergeParent = <monorepo commit before last sync>
      splitSha = <last split SHA for incremental push>
EOF
  exit 0
}

version() {
  echo "platypus-subtree version $VERSION"
  exit 0
}

#------------------------------------------------------------------------------
# Commands:
#------------------------------------------------------------------------------

# Initialize an existing directory as a subtree (link to existing upstream)
# Usage: command:init <prefix> [-r <remote>] [-b <branch>]
# This fetches from the upstream and merges to establish a merge base
command:init() {
  local prefix=""
  local remote=""
  local branch="main"
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -r|--remote)
        remote="$2"
        shift 2
        ;;
      -b|--branch)
        branch="$2"
        shift 2
        ;;
      -*)
        error "Unknown option for init: $1"
        ;;
      *)
        if [[ -z "$prefix" ]]; then
          prefix="$1"
        else
          error "Unexpected argument: $1"
        fi
        shift
        ;;
    esac
  done
  
  [[ -n "$prefix" ]] || error "Usage: platypus subtree init <prefix> [-r <remote>] [-b <branch>]"
  
  # Normalize and validate prefix
  prefix=$(subtree:normalize-prefix "$prefix")
  
  # Check directory exists
  subtree:assert-directory-exists "$prefix"
  
  # Check not already configured
  if config:exists "$prefix"; then
    error "Subtree '$prefix' is already configured in $CONFIG_FILE."
  fi
  
  # Prompt for remote if not provided
  if [[ -z "$remote" ]]; then
    err "No remote specified. Use -r <remote> to specify the upstream repository."
    err "Example: platypus subtree init $prefix -r git@github.com:owner/repo.git"
    error "Remote is required for init."
  fi
  
  # Ensure clean worktree
  subtree:assert-clean-worktree
  
  say "Initializing subtree '$prefix' from $remote..."
  o "Branch: $branch"
  
  if $dry_run; then
    say "[dry-run] Would fetch from: $remote ($branch)"
    say "[dry-run] Would merge to establish subtree relationship"
    say "[dry-run] Would create config for '$prefix' in $CONFIG_FILE"
    return 0
  fi
  
  # Capture pre-merge parent BEFORE the merge (stable reference)
  local preMergeParent
  preMergeParent=$(git rev-parse HEAD)
  
  # Create config entry first (so it can be included in merge commit)
  config:set "$prefix" remote "$remote"
  config:set "$prefix" branch "$branch"
  
  # Fetch from upstream
  say "Fetching from upstream..."
  RUN git fetch "$remote" "$branch"
  
  local upstream_sha
  upstream_sha=$(git rev-parse FETCH_HEAD)
  o "Upstream SHA: $upstream_sha"
  
  # Merge to establish subtree relationship
  # Use -Xsubtree=prefix with --allow-unrelated-histories since upstream may have different history
  say "Establishing subtree merge base..."
  RUN git merge -Xsubtree="$prefix" --allow-unrelated-histories FETCH_HEAD \
    -m "Initialize subtree '$prefix' from $remote"
  
  # Record sync state
  config:set "$prefix" upstream "$upstream_sha"
  config:set "$prefix" preMergeParent "$preMergeParent"
  
  # Stage and amend to include config in the merge commit
  RUN git add "$CONFIG_PATH"
  RUN git commit --amend --no-edit
  
  say "Subtree '$prefix' initialized from $remote ($branch)."
  say ""
  say "Next steps:"
  say "  - Pull upstream changes with: platypus subtree pull $prefix"
  say "  - Push local changes with: platypus subtree push $prefix"
}

# Add a new subtree from a remote repository
# Usage: command:add <prefix> <repo> [<ref>]
command:add() {
  local prefix=""
  local repo=""
  local ref="main"
  local squash_opt=""
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --squash)
        squash_opt="--squash"
        shift
        ;;
      -*)
        error "Unknown option for add: $1"
        ;;
      *)
        if [[ -z "$prefix" ]]; then
          prefix="$1"
        elif [[ -z "$repo" ]]; then
          repo="$1"
        else
          ref="$1"
        fi
        shift
        ;;
    esac
  done
  
  [[ -n "$prefix" ]] || error "Usage: platypus subtree add <prefix> <repo> [<ref>]"
  [[ -n "$repo" ]] || error "Usage: platypus subtree add <prefix> <repo> [<ref>]"
  
  # Normalize prefix
  prefix=$(subtree:normalize-prefix "$prefix")
  
  # Check directory doesn't exist
  subtree:assert-directory-not-exists "$prefix"
  
  # Check not already configured
  if config:exists "$prefix"; then
    error "Subtree '$prefix' is already configured in $CONFIG_FILE."
  fi
  
  # Ensure clean worktree
  subtree:assert-clean-worktree
  
  say "Adding subtree '$prefix' from $repo ($ref)..."
  
  if $dry_run; then
    say "[dry-run] Would run: git subtree add --prefix=$prefix $squash_opt $repo $ref"
    say "[dry-run] Would create config for '$prefix' in $CONFIG_FILE"
    return 0
  fi
  
  # Capture pre-merge parent BEFORE the subtree add (stable reference)
  local preMergeParent
  preMergeParent=$(git rev-parse HEAD)
  
  # Use git subtree add
  RUN git subtree add --prefix="$prefix" $squash_opt "$repo" "$ref"
  
  # Record config
  config:set "$prefix" remote "$repo"
  config:set "$prefix" branch "$ref"
  
  # Record sync state
  local upstream
  upstream=$(git rev-parse FETCH_HEAD 2>/dev/null || echo "")
  
  if [[ -n "$upstream" ]]; then
    config:set "$prefix" upstream "$upstream"
  fi
  config:set "$prefix" preMergeParent "$preMergeParent"
  
  # Stage and amend to include config
  RUN git add "$CONFIG_PATH"
  RUN git commit --amend --no-edit
  
  say "Subtree '$prefix' added from $repo ($ref)."
}

# Create a new upstream from an existing directory (export)
# Usage: command:create <prefix> <upstream> [-b <branch>]
command:create() {
  local prefix=""
  local upstream=""
  local branch="main"
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -b|--branch)
        branch="$2"
        shift 2
        ;;
      -*)
        error "Unknown option for create: $1"
        ;;
      *)
        if [[ -z "$prefix" ]]; then
          prefix="$1"
        elif [[ -z "$upstream" ]]; then
          upstream="$1"
        else
          error "Unexpected argument: $1"
        fi
        shift
        ;;
    esac
  done
  
  [[ -n "$prefix" ]] || error "Usage: platypus subtree create <prefix> <upstream> [-b <branch>]"
  [[ -n "$upstream" ]] || error "Usage: platypus subtree create <prefix> <upstream> [-b <branch>]"
  
  # Normalize prefix
  prefix=$(subtree:normalize-prefix "$prefix")
  
  # Check directory exists and is not empty
  subtree:assert-directory-exists "$prefix"
  
  # Check not already configured
  if config:exists "$prefix"; then
    error "Subtree '$prefix' is already configured in $CONFIG_FILE."
  fi
  
  # Ensure clean worktree
  subtree:assert-clean-worktree
  
  # Test upstream is accessible
  o "Testing upstream access..."
  if ! git ls-remote "$upstream" &>/dev/null; then
    error "Cannot access upstream: $upstream"
  fi
  
  say "Creating subtree '$prefix' with upstream $upstream..."
  o "Branch: $branch"
  
  if $dry_run; then
    say "[dry-run] Would run: git subtree split --prefix=$prefix --rejoin"
    say "[dry-run] Would push to: $upstream ($branch)"
    say "[dry-run] Would create config for '$prefix' in $CONFIG_FILE"
    return 0
  fi
  
  # Capture pre-merge parent BEFORE the split --rejoin (stable reference)
  local preMergeParent
  preMergeParent=$(git rev-parse HEAD)
  
  # Split with --rejoin to establish merge base
  # This creates a merge commit that links the subtree history
  local temp_branch="subtree-create-$$"
  say "Splitting subtree history..."
  local split_sha
  split_sha=$(git subtree split --prefix="$prefix" --rejoin -b "$temp_branch")
  o "Split SHA: $split_sha"
  
  # Push to upstream
  say "Pushing to upstream..."
  if ! RUN git push "$upstream" "$temp_branch:$branch"; then
    # Cleanup on failure
    git branch -D "$temp_branch" 2>/dev/null || true
    error "Failed to push to upstream: $upstream"
  fi
  
  # Create config
  config:set "$prefix" remote "$upstream"
  config:set "$prefix" branch "$branch"
  config:set "$prefix" splitSha "$split_sha"
  config:set "$prefix" upstream "$split_sha"
  config:set "$prefix" preMergeParent "$preMergeParent"
  
  # Stage and amend to include config in the rejoin commit
  RUN git add "$CONFIG_PATH"
  RUN git commit --amend --no-edit
  
  # Cleanup temp branch
  git branch -D "$temp_branch" 2>/dev/null || true
  
  say "Subtree '$prefix' created and pushed to $upstream ($branch)."
  say ""
  say "Next steps:"
  say "  - External contributors can now clone and work on $upstream"
  say "  - Pull their changes with: platypus subtree pull $prefix"
  say "  - Push your changes with: platypus subtree push $prefix"
}

# Pull upstream changes into subtree
# Usage: command:pull <prefix>
command:pull() {
  local prefix=""
  local squash_opt=""
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --squash)
        squash_opt="--squash"
        shift
        ;;
      -*)
        error "Unknown option for pull: $1"
        ;;
      *)
        if [[ -z "$prefix" ]]; then
          prefix="$1"
        else
          error "Unexpected argument: $1"
        fi
        shift
        ;;
    esac
  done
  
  [[ -n "$prefix" ]] || error "Usage: platypus subtree pull <prefix>"
  
  # Normalize prefix
  prefix=$(subtree:normalize-prefix "$prefix")
  
  # Check configured
  subtree:assert-configured "$prefix"
  
  # Ensure clean worktree
  subtree:assert-clean-worktree
  
  # Get config
  local remote branch
  remote=$(config:get "$prefix" remote) || error "No remote configured for '$prefix'"
  branch=$(config:get "$prefix" branch) || branch="main"
  
  say "Pulling '$prefix' from $remote ($branch)..."
  
  if $dry_run; then
    say "[dry-run] Would run: git fetch $remote $branch"
    say "[dry-run] Would run: git subtree merge --prefix=$prefix $squash_opt FETCH_HEAD"
    return 0
  fi
  
  # Capture pre-merge parent BEFORE the merge (stable reference)
  local preMergeParent
  preMergeParent=$(git rev-parse HEAD)
  
  # Fetch
  o "Fetching $remote $branch..."
  RUN git fetch "$remote" "$branch"
  
  # Merge using git subtree
  o "Merging into $prefix..."
  RUN git subtree merge --prefix="$prefix" $squash_opt FETCH_HEAD
  
  # Update config
  local upstream
  upstream=$(git rev-parse FETCH_HEAD)
  
  config:set "$prefix" upstream "$upstream"
  config:set "$prefix" preMergeParent "$preMergeParent"
  
  # Stage config and amend
  RUN git add "$CONFIG_PATH"
  RUN git commit --amend --no-edit
  
  say "Subtree '$prefix' pulled from $remote ($branch)."
}

# Push subtree changes to upstream
# Usage: command:push <prefix>
command:push() {
  local prefix=""
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -*)
        error "Unknown option for push: $1"
        ;;
      *)
        if [[ -z "$prefix" ]]; then
          prefix="$1"
        else
          error "Unexpected argument: $1"
        fi
        shift
        ;;
    esac
  done
  
  [[ -n "$prefix" ]] || error "Usage: platypus subtree push <prefix>"
  
  # Normalize prefix
  prefix=$(subtree:normalize-prefix "$prefix")
  
  # Check configured
  subtree:assert-configured "$prefix"
  
  # Ensure clean worktree
  subtree:assert-clean-worktree
  
  # Get config
  local remote branch splitSha
  remote=$(config:get "$prefix" remote) || error "No remote configured for '$prefix'"
  branch=$(config:get "$prefix" branch) || branch="main"
  splitSha=$(config:get "$prefix" splitSha 2>/dev/null || echo "")
  
  say "Pushing '$prefix' to $remote ($branch)..."
  
  # Build split command
  # We use --rejoin to create a merge commit marking the split point.
  # This allows subsequent splits to skip already-processed history.
  local split_args="--prefix=$prefix --rejoin"
  local temp_branch="platypus-split-$$"
  
  if $dry_run; then
    say "[dry-run] Would run: git subtree split $split_args -b $temp_branch"
    say "[dry-run] Would run: git push $remote $temp_branch:$branch"
    return 0
  fi
  
  # Capture pre-rejoin parent BEFORE the split (stable reference)
  # The --rejoin flag creates a merge commit that we'll amend
  local preMergeParent
  preMergeParent=$(git rev-parse HEAD)
  
  # Split with --rejoin for incremental optimization
  o "Splitting subtree..."
  # shellcheck disable=SC2086
  RUN git subtree split $split_args -b "$temp_branch"
  
  # Push
  o "Pushing to $remote..."
  RUN git push "$remote" "$temp_branch:$branch"
  
  # Record the split SHA for status/reference (optional, --rejoin handles optimization)
  local new_splitSha
  new_splitSha=$(git rev-parse "$temp_branch")
  config:set "$prefix" splitSha "$new_splitSha"
  config:set "$prefix" preMergeParent "$preMergeParent"
  
  # Cleanup temp branch
  RUN git branch -D "$temp_branch"
  
  # Stage config update (--rejoin already created a merge commit, so we amend it)
  RUN git add "$CONFIG_PATH"
  RUN git commit --amend --no-edit
  
  say "Subtree '$prefix' pushed to $remote ($branch)."
}

# Sync subtree bidirectionally (pull then push)
# Usage: command:sync <prefix>
command:sync() {
  local prefix=""
  local squash_opt=""
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --squash)
        squash_opt="--squash"
        shift
        ;;
      -*)
        error "Unknown option for sync: $1"
        ;;
      *)
        if [[ -z "$prefix" ]]; then
          prefix="$1"
        else
          error "Unexpected argument: $1"
        fi
        shift
        ;;
    esac
  done
  
  [[ -n "$prefix" ]] || error "Usage: platypus subtree sync <prefix>"
  
  # Normalize prefix
  prefix=$(subtree:normalize-prefix "$prefix")
  
  # Check configured
  subtree:assert-configured "$prefix"
  
  # Get config for display
  local remote branch
  remote=$(config:get "$prefix" remote) || error "No remote configured for '$prefix'"
  branch=$(config:get "$prefix" branch) || branch="main"
  
  say "Syncing '$prefix' with $remote ($branch)..."
  say ""
  
  if $dry_run; then
    say "[dry-run] Would pull then push '$prefix'"
    say ""
    say "=== Pull phase ==="
    command:pull "$prefix" $squash_opt
    say ""
    say "=== Push phase ==="
    command:push "$prefix"
    return 0
  fi
  
  # Step 1: Pull upstream changes
  say "=== Pull phase ==="
  command:pull "$prefix" $squash_opt
  
  say ""
  
  # Step 2: Push local changes
  say "=== Push phase ==="
  command:push "$prefix"
  
  say ""
  say "Subtree '$prefix' synced with $remote ($branch)."
}

# Show status of subtree(s)
# Usage: command:status [<prefix>]
command:status() {
  local prefix="${1:-}"
  
  ensure-repo-root
  
  if [[ -n "$prefix" ]]; then
    # Status for single subtree
    prefix=$(subtree:normalize-prefix "$prefix")
    subtree:assert-configured "$prefix"
    show-subtree-status "$prefix"
  else
    # Status for all subtrees
    local subtrees
    subtrees=$(config:list)
    
    if [[ -z "$subtrees" ]]; then
      say "No subtrees configured."
      say "Use 'platypus subtree init <prefix>' or 'platypus subtree add <prefix> <repo>' to add one."
      return 0
    fi
    
    while IFS= read -r p; do
      show-subtree-status "$p"
      echo ""
    done <<< "$subtrees"
  fi
}

# Helper to show status for a single subtree
show-subtree-status() {
  local prefix=$1
  
  local remote branch upstream preMergeParent splitSha
  remote=$(config:get "$prefix" remote 2>/dev/null || echo "(not set)")
  branch=$(config:get "$prefix" branch 2>/dev/null || echo "(not set)")
  upstream=$(config:get "$prefix" upstream 2>/dev/null || echo "(not set)")
  preMergeParent=$(config:get "$prefix" preMergeParent 2>/dev/null || echo "(not set)")
  splitSha=$(config:get "$prefix" splitSha 2>/dev/null || echo "(not set)")
  
  say "Subtree: $prefix"
  say "  Remote:          $remote"
  say "  Branch:          $branch"
  say "  Upstream:        ${upstream:0:12}..."
  say "  PreMergeParent:  ${preMergeParent:0:12}..."
  say "  SplitSHA:        ${splitSha:0:12}..."
  
  # Check if directory exists
  if [[ ! -d "$REPO_ROOT/$prefix" ]]; then
    say "  Status:   MISSING (directory does not exist)"
    return
  fi
  
  # Could add ahead/behind count here with git rev-list
  say "  Status:   OK"
}

# List all configured subtrees
# Usage: command:list
command:list() {
  ensure-repo-root
  
  local subtrees
  subtrees=$(config:list)
  
  if [[ -z "$subtrees" ]]; then
    say "No subtrees configured in $CONFIG_FILE."
    return 0
  fi
  
  if $quiet_wanted; then
    echo "$subtrees"
  else
    say "Configured subtrees:"
    while IFS= read -r prefix; do
      local remote branch
      remote=$(config:get "$prefix" remote 2>/dev/null || echo "")
      branch=$(config:get "$prefix" branch 2>/dev/null || echo "main")
      say "  $prefix -> $remote ($branch)"
    done <<< "$subtrees"
  fi
}

#------------------------------------------------------------------------------
# Option parsing:
#------------------------------------------------------------------------------

get-options() {
  local args=()
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        usage
        ;;
      -v|--verbose)
        verbose_wanted=true
        shift
        ;;
      -q|--quiet)
        quiet_wanted=true
        shift
        ;;
      -n|--dry-run)
        dry_run=true
        shift
        ;;
      -d|--debug)
        debug_wanted=true
        verbose_wanted=true
        shift
        ;;
      --version)
        version
        ;;
      --)
        shift
        args+=("$@")
        break
        ;;
      -*)
        # Pass through to command - might be command-specific option
        args+=("$1")
        shift
        ;;
      *)
        args+=("$1")
        shift
        ;;
    esac
  done
  
  # Return remaining args
  printf '%s\n' "${args[@]}"
}

#------------------------------------------------------------------------------
# Main:
#------------------------------------------------------------------------------

main() {
  # Parse global options first
  local args=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        usage
        ;;
      -v|--verbose)
        verbose_wanted=true
        shift
        ;;
      -q|--quiet)
        quiet_wanted=true
        shift
        ;;
      -n|--dry-run)
        dry_run=true
        shift
        ;;
      -d|--debug)
        debug_wanted=true
        verbose_wanted=true
        shift
        ;;
      --version)
        version
        ;;
      --)
        shift
        args+=("$@")
        break
        ;;
      -*)
        # Pass to command
        args+=("$1")
        shift
        ;;
      *)
        args+=("$1")
        shift
        ;;
    esac
  done
  
  set -- "${args[@]}"
  
  if [[ $# -eq 0 ]]; then
    usage
  fi

  # Initialize repo root
  find-repo-root

  local command=$1
  shift

  case "$command" in
    init)
      command:init "$@"
      ;;
    add)
      command:add "$@"
      ;;
    create)
      command:create "$@"
      ;;
    pull)
      command:pull "$@"
      ;;
    push)
      command:push "$@"
      ;;
    sync)
      command:sync "$@"
      ;;
    status)
      command:status "$@"
      ;;
    list)
      command:list "$@"
      ;;
    help|--help|-h)
      usage
      ;;
    *)
      error "Unknown subtree command: $command. Use 'platypus subtree --help' for usage."
      ;;
  esac
}

#------------------------------------------------------------------------------
# Entry point (when run directly):
#------------------------------------------------------------------------------

[[ ${BASH_SOURCE[0]} != "$0" ]] || main "$@"
