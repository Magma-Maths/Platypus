#!/usr/bin/env bash
# shellcheck disable=SC2034,SC2154  # Variables used via sourced platypus-common.bash
#
# platypus-subtree.sh - Manage Git subtrees in the monorepo
#
# Copyright 2025 - Edgar Costa
#
# Part of Platypus - keeps Git monorepo in sync with SVN and subtrees.
# Configuration file format (.gitsubtrees):
#   [subtree "lib/foo"]
#       remote = git@github.com:owner/foo.git
#       branch = main
#       upstream = <last synced upstream commit>
#       preMergeParent = <monorepo commit BEFORE last sync>
#       splitSha = <last split result for incremental push>
#

set -e

#------------------------------------------------------------------------------
# Source shared utilities:
#------------------------------------------------------------------------------

# shellcheck source=platypus-common.bash
source "$(dirname "${BASH_SOURCE[0]}")/platypus-common.bash"

#------------------------------------------------------------------------------
# Guard: ensure shared globals are present (enforce single entrypoint)
#------------------------------------------------------------------------------

subtree:ensure-globals() {
  ensure:shared-globals
}

#------------------------------------------------------------------------------
# Subtree-specific state (quiet_wanted, verbose_wanted, dry_run, debug_wanted
# are inherited from platypus-common.bash):
#------------------------------------------------------------------------------

# Set during startup
REPO_ROOT=""
CONFIG_PATH=""

#------------------------------------------------------------------------------
# Utility functions (say, o, err, error, debug, RUN in platypus-common.bash):
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Repository and config file location:
#------------------------------------------------------------------------------

# Ensure we're in a git repo and have found the config path
ensure-repo-root() {
  if [[ -z "$REPO_ROOT" ]]; then
    git:find-repo-root  # Sets REPO_ROOT from platypus-common.bash
  fi
  CONFIG_PATH="$REPO_ROOT/$PLATYPUS_SUBTREE_CONFIG"
}

#------------------------------------------------------------------------------
# Configuration functions (.gitsubtrees):
#
# Config file uses git-config INI format, allowing us to use `git config -f`
# for reading and writing. Example:
#
#   [subtree "lib/foo"]
#       remote = git@github.com:owner/foo.git
#       branch = main
#       upstream = abc123...
#       parent = def456...
#       splitSha = 789abc...
#------------------------------------------------------------------------------

subtree:ensure-config-path() {
  if [[ -z "$CONFIG_PATH" || -z "$REPO_ROOT" ]]; then
    ensure-repo-root
  fi
}

config:get() {
  local prefix=$1
  local key=$2
  subtree:ensure-config-path
  
  if [[ ! -f "$CONFIG_PATH" ]]; then
    return 1
  fi
  
  git config -f "$CONFIG_PATH" "subtree.${prefix}.${key}" 2>/dev/null
}

config:set() {
  local prefix=$1
  local key=$2
  local value=$3
  subtree:ensure-config-path
  
  # Create config file if it doesn't exist
  if [[ ! -f "$CONFIG_PATH" ]]; then
    cat > "$CONFIG_PATH" << 'EOF'
# Platypus subtree configuration
# This file tracks Git subtrees managed by platypus.
# Format is similar to .gitmodules.
#
# Do not edit manually unless you know what you're doing.
# Use: platypus subtree init/add/pull/push commands.

EOF
  fi
  
  git config -f "$CONFIG_PATH" "subtree.${prefix}.${key}" "$value"
}

config:unset() {
  local prefix=$1
  local key=$2
  subtree:ensure-config-path
  
  if [[ -f "$CONFIG_PATH" ]]; then
    git config -f "$CONFIG_PATH" --unset "subtree.${prefix}.${key}" 2>/dev/null || true
  fi
}

config:remove-section() {
  local prefix=$1
  subtree:ensure-config-path
  
  if [[ -f "$CONFIG_PATH" ]]; then
    git config -f "$CONFIG_PATH" --remove-section "subtree.${prefix}" 2>/dev/null || true
  fi
}

config:exists() {
  local prefix=$1
  subtree:ensure-config-path
  
  if [[ ! -f "$CONFIG_PATH" ]]; then
    return 1
  fi
  
  # git config keeps slashes in section names, so we match literally
  # We need to escape dots in prefix for regex, but keep slashes
  local escaped_prefix="${prefix//./\\.}"
  git config -f "$CONFIG_PATH" --get-regexp "^subtree\\.${escaped_prefix}\\." &>/dev/null
}

config:list() {
  subtree:ensure-config-path
  
  if [[ ! -f "$CONFIG_PATH" ]]; then
    return 0
  fi
  
  git config -f "$CONFIG_PATH" --get-regexp '^subtree\.' 2>/dev/null |
    sed -n 's/^subtree\.\([^.]*\)\.remote.*/\1/p' |
    sort -u
}

# Assert no configured subtree overlaps with the given prefix (either is a parent
# or child path). This prevents ambiguous subtree operations.
subtree:assert-no-overlap() {
  local prefix=$1

  local existing
  existing=$(config:list)

  while IFS= read -r p; do
    [[ -z "$p" ]] && continue
    [[ "$p" == "$prefix" ]] && continue

    # Add trailing slash for path-boundary-safe comparisons
    if [[ "$p"/ == "$prefix"/* || "$prefix"/ == "$p"/* ]]; then
      error "Subtree prefix '$prefix' overlaps existing subtree '$p'. Choose a non-overlapping prefix."
    fi
  done <<< "$existing"
}

config:get-all() {
  local prefix=$1
  subtree:ensure-config-path
  
  if [[ ! -f "$CONFIG_PATH" ]]; then
    return 0
  fi
  
  # Escape dots in prefix for regex, keep slashes
  local escaped_prefix="${prefix//./\\.}"
  git config -f "$CONFIG_PATH" --get-regexp "^subtree\\.${escaped_prefix}\\." 2>/dev/null |
    sed "s/^subtree\\.${escaped_prefix}\\.//"
}

config:update-and-amend() {
  local prefix=$1
  shift
  
  # Update all key=value pairs
  while [[ $# -gt 0 ]]; do
    local key="${1%%=*}"
    local value="${1#*=}"
    config:set "$prefix" "$key" "$value"
    shift
  done
  
  # Stage and amend
  RUN git add "$CONFIG_PATH"
  RUN git commit --amend --no-edit
}

ref:is-valid() {
  [[ -n "$1" ]] && git rev-parse "$1" &>/dev/null
}

#------------------------------------------------------------------------------
# Subtree helper functions:
#------------------------------------------------------------------------------

subtree:assert-configured() {
  local prefix=$1
  
  if ! config:exists "$prefix"; then
    error "Subtree '$prefix' is not configured in $PLATYPUS_SUBTREE_CONFIG.
Use 'platypus subtree init $prefix' or 'platypus subtree add $prefix <repo>' first."
  fi
}

subtree:assert-directory-exists() {
  local prefix=$1
  
  local dir="$REPO_ROOT/$prefix"
  if [[ ! -d "$dir" ]]; then
    error "Directory '$prefix' does not exist."
  fi
  
  if [[ -z "$(ls -A "$dir" 2>/dev/null)" ]]; then
    error "Directory '$prefix' is empty."
  fi
}

subtree:assert-directory-not-exists() {
  local prefix=$1
  
  local dir="$REPO_ROOT/$prefix"
  if [[ -d "$dir" ]] && [[ -n "$(ls -A "$dir" 2>/dev/null)" ]]; then
    error "Directory '$prefix' already exists and is not empty.
Use 'platypus subtree init $prefix' to register an existing directory."
  fi
}

subtree:fetch() {
  local prefix=$1
  
  subtree:assert-configured "$prefix"
  
  local remote branch
  remote=$(config:get "$prefix" remote) || error "No remote configured for '$prefix'"
  branch=$(config:get "$prefix" branch) || branch="main"
  
  o "Fetching $remote ($branch)..."
  RUN git fetch "$remote" "$branch"
}

subtree:tracking-ref() {
  local prefix=$1
  # Sanitize prefix for use in ref name (replace / with -)
  echo "subtree/${prefix//\//-}"
}

subtree:assert-clean-worktree() {
  cd "$REPO_ROOT"
  git:assert-clean-worktree  # Uses shared function from platypus-common.bash
}

subtree:normalize-prefix() {
  local prefix=$1
  
  prefix="${prefix%/}"
  
  prefix="${prefix#/}"
  
  if [[ "$prefix" == *".."* ]]; then
    error "Invalid prefix: '$prefix' (contains '..')"
  fi
  
  if [[ "$prefix" == /* ]]; then
    error "Invalid prefix: '$prefix' (absolute path not allowed)"
  fi
  
  if [[ -z "$prefix" ]]; then
    error "Prefix cannot be empty"
  fi
  
  echo "$prefix"
}

subtree:validate() {
  local prefix=$1
  shift
  local -a checks=("$@")
  
  prefix=$(subtree:normalize-prefix "$prefix")
  
  for check in "${checks[@]}"; do
    case "$check" in
      configured)
        subtree:assert-configured "$prefix"
        ;;
      exists)
        subtree:assert-directory-exists "$prefix"
        ;;
      not-exists)
        subtree:assert-directory-not-exists "$prefix"
        ;;
      clean)
        subtree:assert-clean-worktree
        ;;
      *)
        error "Unknown validation check: $check"
        ;;
    esac
  done
  
  echo "$prefix"
}

subtree:announce-dry-run() {
  say "dry-run: no changes will be made"
}

#------------------------------------------------------------------------------
# Help:
#------------------------------------------------------------------------------

subtree:usage() {
  cat <<'EOF'
Usage: platypus subtree <command> [options]

Commands:
  create <prefix> <upstream> [-b <branch>]
  init <prefix> -r <remote> [-b <branch>]
  add <prefix> <repo> [<ref>] [--squash]
  pull <prefix> [--squash]
  push <prefix>
  sync <prefix> [--squash]
  status [<prefix>]
  list

Common options:
  -h|--help  --version  -v|--verbose  -q|--quiet  -n|--dry-run  -d|--debug
EOF
  exit 0
}

subtree:version() {
  echo "platypus version ${PLATYPUS_VERSION:-unknown} (subtree module)"
  exit 0
}

# Commands:
subtree:command:init() {
  local prefix=$1
  local remote=$2
  local branch=${3:-main}

  [[ -n "$prefix" ]] || error "Usage: platypus subtree init <prefix> -r <remote> [-b <branch>]"
  [[ -n "$remote" ]] || error "Usage: platypus subtree init <prefix> -r <remote> [-b <branch>]"

  prefix=$(subtree:validate "$prefix" exists clean)

  if config:exists "$prefix"; then
    error "Subtree '$prefix' is already configured in $PLATYPUS_SUBTREE_CONFIG."
  fi

  subtree:assert-no-overlap "$prefix"

  say "Initializing subtree '$prefix' from $remote..."
  o "Branch: $branch"

  if $dry_run; then
    subtree:announce-dry-run
    return 0
  fi

  local preMergeParent
  preMergeParent=$(git rev-parse HEAD)

  config:set "$prefix" remote "$remote"
  config:set "$prefix" branch "$branch"

  say "Fetching from upstream..."
  RUN git fetch "$remote" "$branch"

  local upstream_sha
  upstream_sha=$(git rev-parse FETCH_HEAD)
  o "Upstream SHA: $upstream_sha"

  say "Establishing subtree merge base..."
  RUN git merge -Xsubtree="$prefix" --allow-unrelated-histories FETCH_HEAD \
    -m "Initialize subtree '$prefix' from $remote"

  config:update-and-amend "$prefix" "upstream=$upstream_sha" "preMergeParent=$preMergeParent"

  say "Subtree '$prefix' initialized from $remote ($branch)."
  say ""
  say "Next steps:"
  say "  - Pull upstream changes with: platypus subtree pull $prefix"
  say "  - Push local changes with: platypus subtree push $prefix"
}

subtree:command:add() {
  local prefix=$1
  local repo=$2
  local ref=${3:-main}
  local squash_opt=${4:-}

  [[ -n "$prefix" ]] || error "Usage: platypus subtree add <prefix> <repo> [<ref>] [--squash]"
  [[ -n "$repo" ]] || error "Usage: platypus subtree add <prefix> <repo> [<ref>] [--squash]"
  
  prefix=$(subtree:validate "$prefix" not-exists clean)
  
  if config:exists "$prefix"; then
    error "Subtree '$prefix' is already configured in $PLATYPUS_SUBTREE_CONFIG."
  fi
  
  subtree:assert-no-overlap "$prefix"

  say "Adding subtree '$prefix' from $repo ($ref)..."
  
  if $dry_run; then
    subtree:announce-dry-run
    return 0
  fi
  
  local preMergeParent
  preMergeParent=$(git rev-parse HEAD)
  
  local add_args=(--prefix="$prefix")
  [[ -n "$squash_opt" ]] && add_args+=("$squash_opt")
  add_args+=("$repo" "$ref")
  RUN git subtree add "${add_args[@]}"
  
  config:set "$prefix" remote "$repo"
  config:set "$prefix" branch "$ref"
  
  local upstream
  upstream=$(git rev-parse FETCH_HEAD 2>/dev/null || echo "")
  
  local config_args=("preMergeParent=$preMergeParent")
  if [[ -n "$upstream" ]]; then
    config_args+=("upstream=$upstream")
  fi
  config:update-and-amend "$prefix" "${config_args[@]}"
  
  say "Subtree '$prefix' added from $repo ($ref)."
}

subtree:command:create() {
  local prefix=$1
  local upstream=$2
  local branch=${3:-main}
  
  [[ -n "$prefix" ]] || error "Usage: platypus subtree create <prefix> <upstream> [-b <branch>]"
  [[ -n "$upstream" ]] || error "Usage: platypus subtree create <prefix> <upstream> [-b <branch>]"
  
  prefix=$(subtree:validate "$prefix" exists clean)
  
  if config:exists "$prefix"; then
    error "Subtree '$prefix' is already configured in $PLATYPUS_SUBTREE_CONFIG."
  fi
  
  subtree:assert-no-overlap "$prefix"

  o "Testing upstream access..."
  if ! git ls-remote "$upstream" &>/dev/null; then
    error "Cannot access upstream: $upstream"
  fi
  
  say "Creating subtree '$prefix' with upstream $upstream..."
  o "Branch: $branch"
  
  if $dry_run; then
    subtree:announce-dry-run
    return 0
  fi
  
  local preMergeParent
  preMergeParent=$(git rev-parse HEAD)
  
  local temp_branch="subtree-create-$$"
  say "Splitting subtree history..."
  local split_sha
  split_sha=$(git subtree split --prefix="$prefix" --rejoin -b "$temp_branch")
  o "Split SHA: $split_sha"
  
  say "Pushing to upstream..."
  if ! RUN git push "$upstream" "$temp_branch:$branch"; then
    git branch -D "$temp_branch" 2>/dev/null || true
    error "Failed to push to upstream: $upstream"
  fi
  
  config:update-and-amend "$prefix" \
    "remote=$upstream" \
    "branch=$branch" \
    "splitSha=$split_sha" \
    "upstream=$split_sha" \
    "preMergeParent=$preMergeParent"
  
  git branch -D "$temp_branch" 2>/dev/null || true
  
  say "Subtree '$prefix' created and pushed to $upstream ($branch)."
  say ""
  say "Next steps:"
  say "  - External contributors can now clone and work on $upstream"
  say "  - Pull their changes with: platypus subtree pull $prefix"
  say "  - Push your changes with: platypus subtree push $prefix"
}

subtree:command:pull() {
  local prefix=$1
  local squash_opt=${2:-}
  
  [[ -n "$prefix" ]] || error "Usage: platypus subtree pull <prefix> [--squash]"
  
  prefix=$(subtree:validate "$prefix" configured clean)
  
  local remote branch
  remote=$(config:get "$prefix" remote) || error "No remote configured for '$prefix'"
  branch=$(config:get "$prefix" branch) || error "No branch configured for '$prefix'"
  
  say "Pulling '$prefix' from $remote ($branch)..."
  
  if $dry_run; then
    subtree:announce-dry-run
    return 0
  fi
  
  local preMergeParent
  preMergeParent=$(git rev-parse HEAD)
  
  o "Fetching $remote $branch..."
  RUN git fetch "$remote" "$branch"
  
  o "Merging into $prefix..."
  RUN git subtree merge --prefix="$prefix" $squash_opt FETCH_HEAD
  
  local upstream
  upstream=$(git rev-parse FETCH_HEAD)
  
  config:update-and-amend "$prefix" "upstream=$upstream" "preMergeParent=$preMergeParent"
  
  say "Subtree '$prefix' pulled from $remote ($branch)."
}

subtree:command:push() {
  local prefix=$1
  
  [[ -n "$prefix" ]] || error "Usage: platypus subtree push <prefix>"
  
  prefix=$(subtree:validate "$prefix" configured clean)
  
  local remote branch splitSha
  remote=$(config:get "$prefix" remote) || error "No remote configured for '$prefix'"
  branch=$(config:get "$prefix" branch) || error "No branch configured for '$prefix'"
  splitSha=$(config:get "$prefix" splitSha 2>/dev/null || echo "")
  
  say "Pushing '$prefix' to $remote ($branch)..."
  
  o "Fetching $remote $branch..."
  RUN git fetch "$remote" "$branch"
  local remote_tip
  remote_tip=$(git rev-parse FETCH_HEAD)

  local preMergeParent_cfg current_split=""
  preMergeParent_cfg=$(config:get "$prefix" preMergeParent 2>/dev/null || echo "")

  if ref:is-valid "$splitSha" && ref:is-valid "$preMergeParent_cfg"; then
    local revlist_output
    if revlist_output=$(git rev-list "$preMergeParent_cfg"..HEAD -- "$prefix" 2>/dev/null) \
       && [[ -z "$revlist_output" ]]; then
      o "No changes to $prefix since last sync; using cached splitSha"
      current_split="$splitSha"
    fi
  fi

  if [[ -z "$current_split" ]] && ref:is-valid "$splitSha"; then
    o "Computing incremental split using --onto..."
    current_split=$(git subtree split --prefix="$prefix" --onto="$splitSha" 2>/dev/null || true)
  fi

  if [[ -z "$current_split" ]]; then
    o "Computing full subtree split..."
    current_split=$(git subtree split --prefix="$prefix" 2>/dev/null || true)
  fi

  [[ -n "$current_split" ]] || error "Failed to compute subtree split for '$prefix'. Is git subtree available?"

  if ! git merge-base --is-ancestor "$remote_tip" "$current_split" 2>/dev/null; then
    error "Upstream $remote/$branch has new commits. Run 'platypus subtree pull $prefix' (or sync) first."
  fi

  if [[ "$current_split" == "$remote_tip" ]]; then
    say "No subtree changes to push for '$prefix'; upstream is up to date."
    return 0
  fi

  local split_args=(--prefix="$prefix" --rejoin)
  local temp_branch="platypus-split-$$"
  
  if $dry_run; then
    subtree:announce-dry-run
    return 0
  fi
  
  local preMergeParent
  preMergeParent=$(git rev-parse HEAD)
  
  o "Splitting subtree..."
  RUN git subtree split "${split_args[@]}" -b "$temp_branch"
  
  o "Pushing to $remote..."
  RUN git push "$remote" "$temp_branch:$branch"
  
  local new_splitSha
  new_splitSha=$(git rev-parse "$temp_branch")
  
  RUN git branch -D "$temp_branch"
  
  config:update-and-amend "$prefix" "splitSha=$new_splitSha" "preMergeParent=$preMergeParent"
  
  say "Subtree '$prefix' pushed to $remote ($branch)."
}

subtree:command:sync() {
  local prefix=$1
  local squash_opt=${2:-}
  
  [[ -n "$prefix" ]] || error "Usage: platypus subtree sync <prefix> [--squash]"
  
  prefix=$(subtree:validate "$prefix" configured)
  
  local remote branch
  remote=$(config:get "$prefix" remote) || error "No remote configured for '$prefix'"
  branch=$(config:get "$prefix" branch) || error "No branch configured for '$prefix'"
  
  say "Syncing '$prefix' with $remote ($branch)..."
  say ""
  
  if $dry_run; then
    subtree:announce-dry-run
    return 0
  fi
  
  say "=== Pull phase ==="
  subtree:command:pull "$prefix" "$squash_opt"
  
  say ""
  
  say "=== Push phase ==="
  subtree:command:push "$prefix"
  
  say ""
  say "Subtree '$prefix' synced with $remote ($branch)."
}

subtree:command:status() {
  local prefix="${1:-}"
  
  if [[ -n "$prefix" ]]; then
    # Status for single subtree
    prefix=$(subtree:normalize-prefix "$prefix")
    subtree:assert-configured "$prefix"
    show-subtree-status "$prefix"
  else
    # Status for all subtrees
    local subtrees
    subtrees=$(config:list)
    
    if [[ -z "$subtrees" ]]; then
      say "No subtrees configured."
      say "Use 'platypus subtree init <prefix>' or 'platypus subtree add <prefix> <repo>' to add one."
      return 0
    fi
    
    while IFS= read -r p; do
      show-subtree-status "$p"
      echo ""
    done <<< "$subtrees"
  fi
}

show-subtree-status() {
  local prefix=$1
  
  local remote branch upstream preMergeParent splitSha
  remote=$(config:get "$prefix" remote 2>/dev/null || echo "")
  branch=$(config:get "$prefix" branch 2>/dev/null || echo "")
  upstream=$(config:get "$prefix" upstream 2>/dev/null || echo "(not set)")
  preMergeParent=$(config:get "$prefix" preMergeParent 2>/dev/null || echo "(not set)")
  splitSha=$(config:get "$prefix" splitSha 2>/dev/null || echo "(not set)")
  
  say "Subtree: $prefix"
  say "  Remote:          ${remote:-"(not set)"}"
  say "  Branch:          ${branch:-"(not set)"}"
  say "  Upstream:        ${upstream:0:12}..."
  say "  PreMergeParent:  ${preMergeParent:0:12}..."
  say "  SplitSHA:        ${splitSha:0:12}..."
  
  [[ -n "$remote" ]] || { say "  Status:   MISSING (remote not configured)"; return; }
  [[ -n "$branch" ]] || { say "  Status:   MISSING (branch not configured)"; return; }
  
  if [[ ! -d "$REPO_ROOT/$prefix" ]]; then
    say "  Status:   MISSING (directory does not exist)"
    return
  fi

  local remote_tip
  if ! RUN git fetch "$remote" "$branch"; then
    say "  Status:   ERROR fetching $remote ($branch)"
    return
  fi
  remote_tip=$(git rev-parse FETCH_HEAD 2>/dev/null || true)
  if [[ -z "$remote_tip" ]]; then
    say "  Status:   ERROR determining remote tip for $remote ($branch)"
    return
  fi

  local local_split
  local_split=$(git subtree split --prefix="$prefix" 2>/dev/null || true)
  if [[ -z "$local_split" ]]; then
    say "  Status:   ERROR computing subtree split (is git subtree available?)"
    return
  fi

  local counts behind ahead
  counts=$(git rev-list --left-right --count "$remote_tip...$local_split" 2>/dev/null || echo "0 0")
  behind=${counts%% *}
  ahead=${counts##* }

  if [[ ${behind:-0} -eq 0 && ${ahead:-0} -eq 0 ]]; then
    say "  Status:   up-to-date"
  elif [[ ${behind:-0} -eq 0 ]]; then
    say "  Status:   AHEAD by ${ahead:-0}"
  elif [[ ${ahead:-0} -eq 0 ]]; then
    say "  Status:   BEHIND by ${behind:-0}"
  else
    say "  Status:   DIVERGED (ahead ${ahead:-0}, behind ${behind:-0})"
  fi
}

subtree:command:list() {
  local subtrees
  subtrees=$(config:list)
  
  if [[ -z "$subtrees" ]]; then
    say "No subtrees configured in $PLATYPUS_SUBTREE_CONFIG."
    return 0
  fi
  
  if $quiet_wanted; then
    echo "$subtrees"
  else
    say "Configured subtrees:"
    while IFS= read -r prefix; do
      local remote branch
      remote=$(config:get "$prefix" remote 2>/dev/null || echo "")
      branch=$(config:get "$prefix" branch 2>/dev/null || echo "main")
      say "  $prefix -> $remote ($branch)"
    done <<< "$subtrees"
  fi
}

#------------------------------------------------------------------------------
# Command dispatch:
#------------------------------------------------------------------------------

subtree:dispatch() {
  local cmd=$1
  shift

  if [[ "$cmd" == "help" || "$cmd" == "--help" || "$cmd" == "-h" ]]; then
    subtree:usage
    return 0
  fi

  ensure-repo-root

  case "$cmd" in
    init)
      local branch="main" remote="" args=()
      while [[ $# -gt 0 ]]; do
        case "$1" in
          -r|--remote)
            remote="$2"
            shift 2
            ;;
          -b|--branch)
            branch="$2"
            shift 2
            ;;
          --)
            shift
            args+=("$@")
            break
            ;;
          -*)
            error "Unknown option for init: $1"
            ;;
          *)
            args+=("$1")
            shift
            ;;
        esac
      done
      [[ ${#args[@]} -le 1 ]] || error "Unexpected argument: ${args[1]}"
      subtree:command:init "${args[0]:-}" "$remote" "$branch"
      ;;
    add)
      local squash_opt="" args=()
      while [[ $# -gt 0 ]]; do
        case "$1" in
          --squash)
            squash_opt="--squash"
            shift
            ;;
          --)
            shift
            args+=("$@")
            break
            ;;
          -*)
            error "Unknown option for add: $1"
            ;;
          *)
            args+=("$1")
            shift
            ;;
        esac
      done
      [[ ${#args[@]} -le 3 ]] || error "Unexpected argument: ${args[3]}"
      subtree:command:add "${args[0]:-}" "${args[1]:-}" "${args[2]:-}" "$squash_opt"
      ;;
    create)
      local branch="main" args=()
      while [[ $# -gt 0 ]]; do
        case "$1" in
          -b|--branch)
            branch="$2"
            shift 2
            ;;
          --)
            shift
            args+=("$@")
            break
            ;;
          -*)
            error "Unknown option for create: $1"
            ;;
          *)
            args+=("$1")
            shift
            ;;
        esac
      done
      [[ ${#args[@]} -le 2 ]] || error "Unexpected argument: ${args[2]}"
      subtree:command:create "${args[0]:-}" "${args[1]:-}" "$branch"
      ;;
    pull)
      local squash_opt="" args=()
      while [[ $# -gt 0 ]]; do
        case "$1" in
          --squash)
            squash_opt="--squash"
            shift
            ;;
          --)
            shift
            args+=("$@")
            break
            ;;
          -*)
            error "Unknown option for pull: $1"
            ;;
          *)
            args+=("$1")
            shift
            ;;
        esac
      done
      [[ ${#args[@]} -le 1 ]] || error "Unexpected argument: ${args[1]}"
      subtree:command:pull "${args[0]:-}" "$squash_opt"
      ;;
    push)
      [[ $# -le 1 ]] || error "Unexpected argument: $2"
      subtree:command:push "${1:-}"
      ;;
    sync)
      local squash_opt="" args=()
      while [[ $# -gt 0 ]]; do
        case "$1" in
          --squash)
            squash_opt="--squash"
            shift
            ;;
          --)
            shift
            args+=("$@")
            break
            ;;
          -*)
            error "Unknown option for sync: $1"
            ;;
          *)
            args+=("$1")
            shift
            ;;
        esac
      done
      [[ ${#args[@]} -le 1 ]] || error "Unexpected argument: ${args[1]}"
      subtree:command:sync "${args[0]:-}" "$squash_opt"
      ;;
    status)
      [[ $# -le 1 ]] || error "Unexpected argument: $2"
      subtree:command:status "${1:-}"
      ;;
    list)
      [[ $# -eq 0 ]] || error "Unexpected argument: $1"
      subtree:command:list
      ;;
    *)
      error "Unknown subtree command: $cmd. Use 'platypus subtree --help' for usage."
      ;;
  esac
}

#------------------------------------------------------------------------------
# Main:
#------------------------------------------------------------------------------

subtree:main() {
  subtree:ensure-globals
  common:dispatch subtree:usage subtree:version subtree:dispatch "$@"
}
